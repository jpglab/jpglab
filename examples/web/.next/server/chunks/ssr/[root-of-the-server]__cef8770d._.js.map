{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/kevinschaich/repositories/jpglab/fuse/src/core/interfaces/message-builder.interface.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/core/ptp/ptp-constants.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/core/ptp/ptp-message-builder.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/vendors/sony/sony-constants.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/core/ptp/ptp-protocol.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/properties/device-properties.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/generic/generic-property-mapper.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/interfaces/image.interface.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/generic/generic-ptp-camera.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/vendors/sony/sony-property-mapper.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/vendors/sony/sony-authenticator.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/interfaces/liveview.interface.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/vendors/sony/sony-camera.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/camera-factory.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/transport/usb/usb-device-finder.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/client/discovery.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/utils/event-emitter.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/transport/interfaces/endpoint.interface.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/transport/usb/usb-transport.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/transport/usb/usb-endpoint-manager.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/transport/transport-factory.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/client/photo.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/client/camera.browser.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/client/frame.ts","file:///Users/kevinschaich/repositories/jpglab/fuse/src/camera/properties/property-constants.ts"],"sourcesContent":["/**\n * Message builder interface for constructing and parsing PTP messages\n */\nexport interface MessageBuilderInterface {\n    /**\n     * Build a command message\n     * @param operation - Operation code\n     * @param parameters - Operation parameters\n     * @returns Encoded message\n     */\n    buildCommand(operation: number, parameters?: number[]): Uint8Array\n\n    /**\n     * Build a data message\n     * @param operation - Operation code\n     * @param data - Data payload\n     * @returns Encoded message\n     */\n    buildData(operation: number, data: Uint8Array): Uint8Array\n\n    /**\n     * Parse a response message\n     * @param data - Raw response data\n     * @returns Parsed response\n     */\n    parseResponse(data: Uint8Array): ParsedResponse\n\n    /**\n     * Parse an event message\n     * @param data - Raw event data\n     * @returns Parsed event\n     */\n    parseEvent(data: Uint8Array): ParsedEvent\n\n    /**\n     * Parse data payload\n     * @param data - Raw data\n     * @returns Parsed data\n     */\n    parseData(data: Uint8Array): ParsedData\n\n    /**\n     * Get next transaction ID\n     */\n    getNextTransactionId(): number\n\n    /**\n     * Reset transaction ID (for new sessions)\n     */\n    resetTransactionId(): void\n}\n\n/**\n * Parsed PTP response\n */\nexport interface ParsedResponse {\n    code: number\n    sessionId: number\n    transactionId: number\n    parameters: number[]\n    type: MessageType\n}\n\n/**\n * Parsed PTP event\n */\nexport interface ParsedEvent {\n    code: number\n    sessionId: number\n    transactionId: number\n    parameters: number[]\n}\n\n/**\n * Parsed PTP data\n */\nexport interface ParsedData {\n    sessionId: number\n    transactionId: number\n    payload: Uint8Array\n}\n\n/**\n * Message type enumeration\n */\nexport enum MessageType {\n    COMMAND = 1,\n    DATA = 2,\n    RESPONSE = 3,\n    EVENT = 4,\n}\n\n/**\n * Data converter interface for type conversions\n */\nexport interface DataConverterInterface {\n    /**\n     * Convert value to PTP format\n     * @param value - Value to convert\n     * @param dataType - Target data type\n     */\n    toPTPFormat(value: unknown, dataType: PTPDataType): Uint8Array\n\n    /**\n     * Convert from PTP format\n     * @param data - PTP formatted data\n     * @param dataType - Source data type\n     */\n    fromPTPFormat(data: Uint8Array, dataType: PTPDataType): unknown\n}\n\n/**\n * PTP data types\n */\nexport enum PTPDataType {\n    UINT8 = 0x0001,\n    UINT16 = 0x0003,\n    UINT32 = 0x0005,\n    UINT64 = 0x0007,\n    INT8 = 0x0002,\n    INT16 = 0x0004,\n    INT32 = 0x0006,\n    INT64 = 0x0008,\n    STRING = 0xffff,\n    ARRAY = 0x4000,\n}\n","/**\n * PTP Protocol Constants\n * ISO 15740:2013 Picture Transfer Protocol\n */\n\n/**\n * Container Types (PTP Protocol Section 9.3.1)\n */\nexport const ContainerTypes = {\n    COMMAND_BLOCK: 0x0001,\n    DATA_BLOCK: 0x0002,\n    RESPONSE_BLOCK: 0x0003,\n    EVENT_BLOCK: 0x0004,\n} as const\n\nexport type ContainerType = (typeof ContainerTypes)[keyof typeof ContainerTypes]\n\n/**\n * PTP Operation Codes (Standard Operations 0x1000-0x1FFF)\n */\nexport const PTPOperations = {\n    // Session operations\n    GET_DEVICE_INFO: 0x1001,\n    OPEN_SESSION: 0x1002,\n    CLOSE_SESSION: 0x1003,\n\n    // Storage operations\n    GET_STORAGE_IDS: 0x1004,\n    GET_STORAGE_INFO: 0x1005,\n    GET_NUM_OBJECTS: 0x1006,\n    GET_OBJECT_HANDLES: 0x1007,\n\n    // Object operations\n    GET_OBJECT_INFO: 0x1008,\n    GET_OBJECT: 0x1009,\n    GET_THUMB: 0x100a,\n    DELETE_OBJECT: 0x100b,\n    SEND_OBJECT_INFO: 0x100c,\n    SEND_OBJECT: 0x100d,\n\n    // Capture operations\n    INITIATE_CAPTURE: 0x100e,\n    FORMAT_STORE: 0x100f,\n    RESET_DEVICE: 0x1010,\n    SELF_TEST: 0x1011,\n\n    // Property operations\n    SET_OBJECT_PROTECTION: 0x1012,\n    POWER_DOWN: 0x1013,\n    GET_DEVICE_PROP_DESC: 0x1014,\n    GET_DEVICE_PROP_VALUE: 0x1015,\n    SET_DEVICE_PROP_VALUE: 0x1016,\n    RESET_DEVICE_PROP_VALUE: 0x1017,\n    TERMINATE_OPEN_CAPTURE: 0x1018,\n\n    // Object manipulation\n    MOVE_OBJECT: 0x1019,\n    COPY_OBJECT: 0x101a,\n    GET_PARTIAL_OBJECT: 0x101b,\n    INITIATE_OPEN_CAPTURE: 0x101c,\n} as const\n\nexport type PTPOperationCode = (typeof PTPOperations)[keyof typeof PTPOperations]\n\n/**\n * PTP Response Codes (Standard Responses 0x2000-0x2FFF)\n */\nexport const PTPResponses = {\n    UNDEFINED: 0x2000,\n    OK: 0x2001,\n    GENERAL_ERROR: 0x2002,\n    SESSION_NOT_OPEN: 0x2003,\n    INVALID_TRANSACTION_ID: 0x2004,\n    OPERATION_NOT_SUPPORTED: 0x2005,\n    PARAMETER_NOT_SUPPORTED: 0x2006,\n    INCOMPLETE_TRANSFER: 0x2007,\n    INVALID_STORAGE_ID: 0x2008,\n    INVALID_OBJECT_HANDLE: 0x2009,\n    DEVICE_PROP_NOT_SUPPORTED: 0x200a,\n    INVALID_OBJECT_FORMAT_CODE: 0x200b,\n    STORAGE_FULL: 0x200c,\n    OBJECT_WRITE_PROTECTED: 0x200d,\n    STORE_READ_ONLY: 0x200e,\n    ACCESS_DENIED: 0x200f,\n    NO_THUMBNAIL_PRESENT: 0x2010,\n    SELF_TEST_FAILED: 0x2011,\n    PARTIAL_DELETION: 0x2012,\n    STORE_NOT_AVAILABLE: 0x2013,\n    SPECIFICATION_BY_FORMAT_UNSUPPORTED: 0x2014,\n    NO_VALID_OBJECT_INFO: 0x2015,\n    INVALID_CODE_FORMAT: 0x2016,\n    UNKNOWN_VENDOR_CODE: 0x2017,\n    CAPTURE_ALREADY_TERMINATED: 0x2018,\n    DEVICE_BUSY: 0x2019,\n    INVALID_PARENT_OBJECT: 0x201a,\n    INVALID_DEVICE_PROP_FORMAT: 0x201b,\n    INVALID_DEVICE_PROP_VALUE: 0x201c,\n    INVALID_PARAMETER: 0x201d,\n    SESSION_ALREADY_OPEN: 0x201e,\n    TRANSACTION_CANCELLED: 0x201f,\n    SPECIFICATION_OF_DESTINATION_UNSUPPORTED: 0x2020,\n} as const\n\nexport type PTPResponseCode = (typeof PTPResponses)[keyof typeof PTPResponses]\n\n/**\n * PTP Event Codes (Standard Events 0x4000-0x4FFF)\n */\nexport const PTPEvents = {\n    UNDEFINED: 0x4000,\n    CANCEL_TRANSACTION: 0x4001,\n    OBJECT_ADDED: 0x4002,\n    OBJECT_REMOVED: 0x4003,\n    STORE_ADDED: 0x4004,\n    STORE_REMOVED: 0x4005,\n    DEVICE_PROP_CHANGED: 0x4006,\n    OBJECT_INFO_CHANGED: 0x4007,\n    DEVICE_INFO_CHANGED: 0x4008,\n    REQUEST_OBJECT_TRANSFER: 0x4009,\n    STORE_FULL: 0x400a,\n    DEVICE_RESET: 0x400b,\n    STORAGE_INFO_CHANGED: 0x400c,\n    CAPTURE_COMPLETE: 0x400d,\n    UNREPORTED_STATUS: 0x400e,\n} as const\n\nexport type PTPEventCode = (typeof PTPEvents)[keyof typeof PTPEvents]\n\n/**\n * PTP Device Properties (Standard Properties 0x5000-0x5FFF)\n */\nexport const PTPDeviceProperties = {\n    UNDEFINED: 0x5000,\n    BATTERY_LEVEL: 0x5001,\n    FUNCTIONAL_MODE: 0x5002,\n    IMAGE_SIZE: 0x5003,\n    COMPRESSION_SETTING: 0x5004,\n    WHITE_BALANCE: 0x5005,\n    RGB_GAIN: 0x5006,\n    F_NUMBER: 0x5007,\n    FOCAL_LENGTH: 0x5008,\n    FOCUS_DISTANCE: 0x5009,\n    FOCUS_MODE: 0x500a,\n    EXPOSURE_METERING_MODE: 0x500b,\n    FLASH_MODE: 0x500c,\n    EXPOSURE_TIME: 0x500d,\n    EXPOSURE_PROGRAM_MODE: 0x500e,\n    EXPOSURE_INDEX: 0x500f,\n    EXPOSURE_BIAS_COMPENSATION: 0x5010,\n    DATE_TIME: 0x5011,\n    CAPTURE_DELAY: 0x5012,\n    STILL_CAPTURE_MODE: 0x5013,\n    CONTRAST: 0x5014,\n    SHARPNESS: 0x5015,\n    DIGITAL_ZOOM: 0x5016,\n    EFFECT_MODE: 0x5017,\n    BURST_NUMBER: 0x5018,\n    BURST_INTERVAL: 0x5019,\n    TIMELAPSE_NUMBER: 0x501a,\n    TIMELAPSE_INTERVAL: 0x501b,\n    FOCUS_METERING_MODE: 0x501c,\n    UPLOAD_URL: 0x501d,\n    ARTIST: 0x501e,\n    COPYRIGHT_INFO: 0x501f,\n} as const\n\nexport type PTPDevicePropertyCode = (typeof PTPDeviceProperties)[keyof typeof PTPDeviceProperties]\n\n/**\n * Create reverse lookup maps for debugging\n */\nexport const PTPOperationNames = Object.entries(PTPOperations).reduce(\n    (acc, [name, code]) => {\n        acc[code] = name\n        return acc\n    },\n    {} as Record<number, string>\n)\n\nexport const PTPResponseNames = Object.entries(PTPResponses).reduce(\n    (acc, [name, code]) => {\n        acc[code] = name\n        return acc\n    },\n    {} as Record<number, string>\n)\n\nexport const PTPEventNames = Object.entries(PTPEvents).reduce(\n    (acc, [name, code]) => {\n        acc[code] = name\n        return acc\n    },\n    {} as Record<number, string>\n)\n\nexport const PTPDevicePropertyNames = Object.entries(PTPDeviceProperties).reduce(\n    (acc, [name, code]) => {\n        acc[code] = name\n        return acc\n    },\n    {} as Record<number, string>\n)\n\n/**\n * Helper function to get human-readable code name\n */\nexport function getCodeName(code: number, type: ContainerType): string {\n    switch (type) {\n        case ContainerTypes.COMMAND_BLOCK:\n            return PTPOperationNames[code] || `Unknown Operation 0x${code.toString(16).padStart(4, '0')}`\n        case ContainerTypes.RESPONSE_BLOCK:\n            return PTPResponseNames[code] || `Unknown Response 0x${code.toString(16).padStart(4, '0')}`\n        case ContainerTypes.EVENT_BLOCK:\n            return PTPEventNames[code] || `Unknown Event 0x${code.toString(16).padStart(4, '0')}`\n        default:\n            return `0x${code.toString(16).padStart(4, '0')}`\n    }\n}\n\n/**\n * PTP Error class for protocol errors\n */\nexport class PTPError extends Error {\n    constructor(\n        public readonly code: number,\n        message: string,\n        public readonly operation?: string\n    ) {\n        super(message)\n        this.name = 'PTPError'\n    }\n}\n","/**\n * PTP Message Builder\n * Constructs and parses PTP protocol messages\n */\n\nimport {\n    MessageBuilderInterface,\n    ParsedResponse,\n    ParsedEvent,\n    ParsedData,\n    MessageType,\n} from '@core/interfaces/message-builder.interface'\nimport { ContainerTypes, ContainerType } from './ptp-constants'\n\nexport class PTPMessageBuilder implements MessageBuilderInterface {\n    private transactionId = 0\n\n    /**\n     * Get next transaction ID\n     */\n    getNextTransactionId(): number {\n        this.transactionId++\n        if (this.transactionId > 0xffffffff) {\n            this.transactionId = 1\n        }\n        return this.transactionId\n    }\n\n    /**\n     * Build a command message\n     */\n    buildCommand(operation: number, parameters: number[] = []): Uint8Array {\n        const paramCount = parameters.length\n        const length = 12 + paramCount * 4\n        const buffer = new ArrayBuffer(length)\n        const view = new DataView(buffer)\n\n        // Container header\n        view.setUint32(0, length, true) // Length\n        view.setUint16(4, ContainerTypes.COMMAND_BLOCK, true) // Type\n        view.setUint16(6, operation, true) // Code\n        view.setUint32(8, this.getNextTransactionId(), true) // Transaction ID\n\n        // Parameters (up to 5)\n        for (let index = 0; index < Math.min(paramCount, 5); index++) {\n            const param = parameters[index]\n            if (param !== undefined) {\n                view.setUint32(12 + index * 4, param, true)\n            }\n        }\n\n        return new Uint8Array(buffer)\n    }\n\n    /**\n     * Build a data message\n     */\n    buildData(operation: number, data: Uint8Array): Uint8Array {\n        const length = 12 + data.byteLength\n        const buffer = new ArrayBuffer(length)\n        const view = new DataView(buffer)\n\n        // Container header\n        view.setUint32(0, length, true) // Length\n        view.setUint16(4, ContainerTypes.DATA_BLOCK, true) // Type\n        view.setUint16(6, operation, true) // Code\n        view.setUint32(8, this.transactionId, true) // Use current transaction ID\n\n        // Copy data payload\n        const uint8View = new Uint8Array(buffer)\n        uint8View.set(data, 12)\n\n        return uint8View\n    }\n\n    /**\n     * Parse a response message\n     */\n    parseResponse(data: Uint8Array): ParsedResponse {\n        if (data.byteLength < 12) {\n            throw new Error('Invalid response: too short')\n        }\n\n        const view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\n        const length = view.getUint32(0, true)\n        const type = view.getUint16(4, true)\n        const code = view.getUint16(6, true)\n        const transactionId = view.getUint32(8, true)\n\n        // Parse parameters if present\n        const parameters: number[] = []\n        const paramBytes = length - 12\n        if (paramBytes > 0 && paramBytes <= 20) {\n            // Max 5 parameters\n            const paramCount = paramBytes / 4\n            for (let index = 0; index < paramCount; index++) {\n                parameters.push(view.getUint32(12 + index * 4, true))\n            }\n        }\n\n        return {\n            code,\n            sessionId: 0, // Session ID not in response container\n            transactionId,\n            parameters,\n            type: this.mapContainerTypeToMessageType(type as ContainerType),\n        }\n    }\n\n    /**\n     * Parse an event message\n     */\n    parseEvent(data: Uint8Array): ParsedEvent {\n        if (data.byteLength < 12) {\n            throw new Error('Invalid event: too short')\n        }\n\n        const view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\n        const length = view.getUint32(0, true)\n        view.getUint16(4, true) // Should be EVENT_BLOCK\n        const code = view.getUint16(6, true)\n        const transactionId = view.getUint32(8, true)\n\n        // Parse parameters if present\n        const parameters: number[] = []\n        const paramBytes = length - 12\n        if (paramBytes > 0 && paramBytes <= 12) {\n            // Events typically have up to 3 parameters\n            const paramCount = paramBytes / 4\n            for (let index = 0; index < paramCount; index++) {\n                parameters.push(view.getUint32(12 + index * 4, true))\n            }\n        }\n\n        return {\n            code,\n            sessionId: 0, // Session ID not in event container\n            transactionId,\n            parameters,\n        }\n    }\n\n    /**\n     * Parse data payload\n     */\n    parseData(data: Uint8Array): ParsedData {\n        if (data.byteLength < 12) {\n            throw new Error('Invalid data: too short')\n        }\n\n        const view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\n        view.getUint32(0, true) // Length\n        view.getUint16(4, true) // Should be DATA_BLOCK\n        view.getUint16(6, true) // Code\n        const transactionId = view.getUint32(8, true)\n\n        // Extract payload (everything after header)\n        const payload = new Uint8Array(data.buffer, data.byteOffset + 12, data.byteLength - 12)\n\n        return {\n            sessionId: 0, // Session ID not in data container\n            transactionId,\n            payload,\n        }\n    }\n\n    /**\n     * Helper to map container type to message type\n     */\n    private mapContainerTypeToMessageType(containerType: ContainerType): MessageType {\n        switch (containerType) {\n            case ContainerTypes.COMMAND_BLOCK:\n                return MessageType.COMMAND\n            case ContainerTypes.DATA_BLOCK:\n                return MessageType.DATA\n            case ContainerTypes.RESPONSE_BLOCK:\n                return MessageType.RESPONSE\n            case ContainerTypes.EVENT_BLOCK:\n                return MessageType.EVENT\n            default:\n                throw new Error(`Unknown container type: 0x${(containerType as number).toString(16)}`)\n        }\n    }\n\n    /**\n     * Parse any PTP message and determine its type\n     */\n    parseMessage(data: Uint8Array): { type: MessageType; message: unknown } {\n        if (data.byteLength < 12) {\n            throw new Error('Invalid message: too short')\n        }\n\n        const view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n        const type = view.getUint16(4, true)\n\n        switch (type) {\n            case ContainerTypes.COMMAND_BLOCK:\n                // Commands are typically not received, but handle for completeness\n                return {\n                    type: MessageType.COMMAND,\n                    message: this.parseResponse(data), // Use same structure\n                }\n            case ContainerTypes.DATA_BLOCK:\n                return {\n                    type: MessageType.DATA,\n                    message: this.parseData(data),\n                }\n            case ContainerTypes.RESPONSE_BLOCK:\n                return {\n                    type: MessageType.RESPONSE,\n                    message: this.parseResponse(data),\n                }\n            case ContainerTypes.EVENT_BLOCK:\n                return {\n                    type: MessageType.EVENT,\n                    message: this.parseEvent(data),\n                }\n            default:\n                throw new Error(`Unknown message type: 0x${type.toString(16)}`)\n        }\n    }\n\n    /**\n     * Reset transaction ID (useful for new sessions)\n     */\n    resetTransactionId(): void {\n        this.transactionId = 0\n    }\n\n    /**\n     * Get current transaction ID without incrementing\n     */\n    getCurrentTransactionId(): number {\n        return this.transactionId\n    }\n}\n","/**\n * Sony-specific PTP constants\n * Migrated from src/vendors/sony/sony-codes.ts\n */\n\nimport { PTPOperations, PTPDeviceProperties } from '../../../core/ptp/ptp-constants'\n\n// Sony Operation Codes\nexport const SonyOperations = {\n    ...PTPOperations,\n    // Sony-specific operations (0x9201-0x92FF)\n    SDIO_CONNECT: 0x9201,\n    SDIO_GET_EXT_DEVICE_INFO: 0x9202,\n    SET_DEVICE_PROPERTY_VALUE: 0x9205,\n    CONTROL_DEVICE_PROPERTY: 0x9207,\n    GET_ALL_EXT_DEVICE_PROP_INFO: 0x9209,\n    SDIO_GET_OSD_IMAGE: 0x9238,\n} as const\n\n// Sony Device Properties\nexport const SonyDeviceProperties = {\n    ...PTPDeviceProperties,\n    // Standard PTP properties used by Sony\n    F_NUMBER: 0x5007, // Aperture value\n    ISO_STANDARD: 0x500f, // Standard PTP ISO property\n    // Sony-specific device properties\n    STILL_CAPTURE_MODE: 0x5013,\n    OSD_IMAGE_MODE: 0xd207,\n    SHUTTER_SPEED: 0xd20d, // Shutter speed\n    CAPTURE_STATUS: 0xd215,\n    ISO_SENSITIVITY_ALT1: 0xd21d, // Alternative ISO property 1\n    ISO_SENSITIVITY: 0xd21e, // ISO sensitivity (main)\n    ISO_SENSITIVITY_ALT2: 0xd21f, // Alternative ISO property 2\n    ISO_SENSITIVITY_ALT3: 0xd220, // Alternative ISO property 3\n    LIVE_VIEW_STATUS: 0xd221,\n    SAVE_MEDIA: 0xd222,\n    DIAL_MODE: 0xd25a,\n    SHUTTER_BUTTON_CONTROL: 0xd2c1,\n    FOCUS_BUTTON_CONTROL: 0xd2c2,\n    LIVE_VIEW_CONTROL: 0xd313,\n} as const\n\n// SDIO Connect Phases\nexport const SDIOPhases = {\n    INITIAL_HANDSHAKE: 0x01,\n    CAPABILITY_EXCHANGE: 0x02,\n    FINAL_AUTHENTICATION: 0x03,\n} as const\n\nexport type SDIOPhase = (typeof SDIOPhases)[keyof typeof SDIOPhases]\n\n// Sony Constants\nexport const SonyConstants = {\n    VENDOR_ID: 0x054c,\n    PRODUCT_ID: 0x096f, // Sony camera (detected via list-devices)\n    PRODUCT_ID_ALPHA: 0x0e78, // Alpha series cameras (alternative)\n    PROTOCOL_VERSION: 0x012c, // Version 3.00\n    DEVICE_PROPERTY_OPTION: 0x00000001, // Enable extended properties\n    LIVE_VIEW_IMAGE_HANDLE: 0xffffc002, // Object handle for live view images\n    OSD_IMAGE_HANDLE: 0xffffc004, // Potential object handle for OSD images\n    LIVE_VIEW_ENABLE: 0x0002, // Enable live view\n    LIVE_VIEW_DISABLE: 0x0001, // Disable live view\n\n    // Dataset type codes\n    SHOT_IMAGE_DATASET: 0xffffc003,\n    OSD_DATASET: 0xffffc006,\n\n    // Shutter/Focus control values\n    SHUTTER_HALF_PRESS: 0x0002,\n    SHUTTER_FULL_PRESS: 0x0001,\n    FOCUS_HALF_PRESS: 0x0002,\n    FOCUS_RELEASE: 0x0001,\n\n    // Property values\n    DIAL_MODE_HOST: 0x01,\n    STILL_CAPTURE_MODE: 0x01,\n    SAVE_MEDIA_HOST: 0x01,\n    OSD_MODE_ON: 0x01,\n    OSD_MODE_OFF: 0x00,\n\n    // Error codes\n    ACCESS_DENIED: 0x200f,\n\n    // Recent image handle\n    RECENT_IMAGE_HANDLE: 0xffffc001,\n\n    // Extended properties parameters\n    GET_ALL_DATA: 0x00000000,\n    ENABLE_EXTENDED: 0x00000001,\n\n    // Data type ranges\n    DATA_TYPE_MIN: 0x0001,\n    DATA_TYPE_MAX: 0x000a,\n    DATA_TYPE_ARRAY_MIN: 0x4001,\n    DATA_TYPE_ARRAY_MAX: 0x400a,\n    DATA_TYPE_STRING: 0xffff,\n\n    // Property code ranges\n    PTP_PROP_MIN: 0x5000,\n    PTP_PROP_MAX: 0x5fff,\n    VENDOR_PROP_MIN: 0xd000,\n    VENDOR_PROP_MAX: 0xdfff,\n} as const\n\n// Helper functions for Sony value formatting\n\n/**\n * Format Sony F-Number (aperture) value\n */\nexport function formatFNumber(value: number): string {\n    // Sony encodes f-number as value * 100\n    return `f/${(value / 100).toFixed(1)}`\n}\n\n/**\n * Format Sony shutter speed value\n */\nexport function formatShutterSpeed(value: number): string {\n    if (value === 0x00000000) return 'BULB'\n    if (value === 0xffffffff) return 'N/A'\n\n    const numerator = (value >> 16) & 0xffff\n    const denominator = value & 0xffff\n\n    if (denominator === 0x000a) {\n        // Real number display (e.g., 1.5\")\n        return `${numerator / 10}\"`\n    } else if (numerator === 0x0001) {\n        // Fraction display (e.g., 1/1000)\n        return `1/${denominator}`\n    } else {\n        return `${numerator}/${denominator}`\n    }\n}\n\n/**\n * Format Sony ISO sensitivity value\n */\nexport function formatISO(value: number): string {\n    // Special AUTO values\n    if (value === 0x00ffffff) return 'ISO AUTO'\n    if (value === 0x01ffffff) return 'Multi Frame NR ISO AUTO'\n    if (value === 0x02ffffff) return 'Multi Frame NR High ISO AUTO'\n\n    // Check for Multi Frame NR modes (prefix byte)\n    const prefix = (value >> 24) & 0xff\n    let mode = ''\n    if (prefix === 0x01) {\n        mode = 'Multi Frame NR '\n    } else if (prefix === 0x02) {\n        mode = 'Multi Frame NR High '\n    }\n\n    // Extract the actual ISO value (lower 24 bits)\n    const isoValue = value & 0xffffff\n\n    // Sony uses direct decimal values for ISO\n    if (isoValue >= 10 && isoValue <= 1000000) {\n        return `${mode}ISO ${isoValue}`\n    }\n\n    return 'ISO Unknown'\n}\n","/**\n * PTP Protocol Implementation\n * Handles PTP protocol operations with injected transport\n */\n\nimport { ProtocolInterface, Operation, Response, Event } from '@core/interfaces/protocol.interface'\nimport { TransportInterface } from '@transport/interfaces/transport.interface'\nimport { MessageBuilderInterface } from '@core/interfaces/message-builder.interface'\nimport { PTPOperations, PTPResponses, PTPError } from './ptp-constants'\nimport { SonyOperations } from '../../camera/vendors/sony/sony-constants'\n\nexport class PTPProtocol implements ProtocolInterface {\n    private sessionId: number | null = null\n    private isOpen = false\n\n    constructor(\n        private readonly transport: TransportInterface,\n        private readonly messageBuilder: MessageBuilderInterface\n    ) {}\n\n    /**\n     * Open a new PTP session\n     */\n    async openSession(sessionId: number): Promise<void> {\n        console.log(`PTP Protocol: Opening session with ID ${sessionId}`)\n        if (this.isOpen) {\n            console.log('PTP Protocol: Session already marked as open locally')\n            return // Don't throw, just return\n        }\n\n        // Build and send OpenSession command\n        const command = this.messageBuilder.buildCommand(PTPOperations.OPEN_SESSION, [sessionId])\n        console.log(`PTP Protocol: Sending OpenSession command...`)\n\n        await this.transport.send(command)\n        console.log(`PTP Protocol: OpenSession command sent, waiting for response...`)\n\n        // Receive response\n        const responseData = await this.transport.receive(512)\n        const response = this.messageBuilder.parseResponse(responseData)\n        console.log(`PTP Protocol: OpenSession response received: 0x${response.code.toString(16)}`)\n\n        // Check response code\n        if (response.code === PTPResponses.SESSION_ALREADY_OPEN) {\n            console.log('PTP Protocol: Camera says session already open, continuing...')\n            this.sessionId = sessionId\n            this.isOpen = true\n            return\n        }\n\n        if (response.code !== PTPResponses.OK) {\n            throw new PTPError(\n                response.code,\n                `Failed to open session: 0x${response.code.toString(16).padStart(4, '0')}`,\n                'OpenSession'\n            )\n        }\n\n        this.sessionId = sessionId\n        this.isOpen = true\n    }\n\n    /**\n     * Close the current PTP session\n     */\n    async closeSession(): Promise<void> {\n        if (!this.isOpen) {\n            return // Already closed\n        }\n\n        try {\n            // Build and send CloseSession command\n            const command = this.messageBuilder.buildCommand(PTPOperations.CLOSE_SESSION)\n\n            await this.transport.send(command)\n\n            // Receive response\n            const responseData = await this.transport.receive(512)\n            const response = this.messageBuilder.parseResponse(responseData)\n\n            // Check response code (be lenient on close)\n            if (response.code !== PTPResponses.OK && response.code !== PTPResponses.SESSION_NOT_OPEN) {\n                console.warn(`CloseSession returned: 0x${response.code.toString(16).padStart(4, '0')}`)\n            }\n        } finally {\n            this.sessionId = null\n            this.isOpen = false\n        }\n    }\n\n    /**\n     * Send a PTP operation\n     */\n    async sendOperation(operation: Operation): Promise<Response> {\n        if (!this.isOpen && operation.code !== PTPOperations.GET_DEVICE_INFO) {\n            throw new PTPError(PTPResponses.SESSION_NOT_OPEN, 'Session not open', 'SendOperation')\n        }\n\n        const transactionId = this.messageBuilder.getNextTransactionId()\n\n        // Determine if this operation expects data if not explicitly set\n        const hasDataPhase =\n            operation.hasDataPhase !== undefined\n                ? operation.hasDataPhase\n                : PTPProtocol.expectsDataIn(operation.code) || operation.data !== undefined\n\n        // Send command phase\n        const command = this.messageBuilder.buildCommand(operation.code, operation.parameters || [])\n        await this.transport.send(command)\n\n        // Handle data phase if present\n        let receivedData: Uint8Array | undefined\n\n        if (hasDataPhase && operation.data) {\n            // Send data (data-out operation)\n            const dataMessage = this.messageBuilder.buildData(operation.code, operation.data)\n            await this.transport.send(dataMessage)\n        } else if (hasDataPhase) {\n            // Receive data (data-in operation)\n            // Use maxDataLength if specified, otherwise use a reasonable default\n            const maxLength = operation.maxDataLength || 65536 // Default to 64KB\n            const dataResponse = await this.transport.receive(maxLength)\n            const parsedData = this.messageBuilder.parseData(dataResponse)\n            receivedData = parsedData.payload\n        }\n\n        // Receive response phase\n        const responseData = await this.transport.receive(512)\n        const parsedResponse = this.messageBuilder.parseResponse(responseData)\n\n        // Build response object\n        const response: Response = {\n            code: parsedResponse.code,\n            sessionId: this.sessionId || 0,\n            transactionId,\n            parameters: parsedResponse.parameters,\n            data: receivedData,\n        }\n\n        return response\n    }\n\n    /**\n     * Receive a PTP event\n     */\n    async receiveEvent(): Promise<Event> {\n        // Events would typically come from an interrupt endpoint\n        // For now, this is a placeholder implementation\n        // Real implementation would need to handle async event polling\n        const eventData = await this.transport.receive(512)\n        const parsedEvent = this.messageBuilder.parseEvent(eventData)\n\n        return {\n            code: parsedEvent.code,\n            sessionId: this.sessionId || 0,\n            transactionId: parsedEvent.transactionId,\n            parameters: parsedEvent.parameters,\n        }\n    }\n\n    /**\n     * Get current session ID\n     */\n    getSessionId(): number | null {\n        return this.sessionId\n    }\n\n    /**\n     * Check if session is open\n     */\n    isSessionOpen(): boolean {\n        return this.isOpen\n    }\n\n    /**\n     * Reset the protocol state\n     */\n    async reset(): Promise<void> {\n        if (this.isOpen) {\n            await this.closeSession()\n        }\n        this.messageBuilder.resetTransactionId()\n        this.sessionId = null\n        this.isOpen = false\n    }\n\n    /**\n     * Get device info (doesn't require open session)\n     */\n    async getDeviceInfo(): Promise<Response> {\n        return this.sendOperation({\n            code: PTPOperations.GET_DEVICE_INFO,\n            hasDataPhase: true,\n        })\n    }\n\n    /**\n     * Helper to send simple commands without data phase\n     */\n    async sendCommand(code: number, parameters?: number[]): Promise<Response> {\n        return this.sendOperation({\n            code,\n            parameters,\n            hasDataPhase: false,\n        })\n    }\n\n    /**\n     * Helper to send commands that receive data\n     */\n    async sendCommandReceiveData(code: number, parameters?: number[]): Promise<Response> {\n        return this.sendOperation({\n            code,\n            parameters,\n            hasDataPhase: true,\n        })\n    }\n\n    /**\n     * Helper to send commands that send data\n     */\n    async sendCommandWithData(code: number, parameters: number[], data: Uint8Array): Promise<Response> {\n        return this.sendOperation({\n            code,\n            parameters,\n            data,\n            hasDataPhase: true,\n        })\n    }\n\n    /**\n     * Check if an operation expects to receive data\n     */\n    static expectsDataIn(operationCode: number): boolean {\n        // Operations that receive data from device\n        const dataInOps: number[] = [\n            PTPOperations.GET_DEVICE_INFO,\n            PTPOperations.GET_STORAGE_IDS,\n            PTPOperations.GET_STORAGE_INFO,\n            PTPOperations.GET_NUM_OBJECTS,\n            PTPOperations.GET_OBJECT_HANDLES,\n            PTPOperations.GET_OBJECT_INFO,\n            PTPOperations.GET_OBJECT,\n            PTPOperations.GET_DEVICE_PROP_DESC,\n            PTPOperations.GET_DEVICE_PROP_VALUE,\n            SonyOperations.SDIO_GET_EXT_DEVICE_INFO,\n            SonyOperations.GET_ALL_EXT_DEVICE_PROP_INFO,\n            SonyOperations.SDIO_GET_OSD_IMAGE,\n        ]\n        return dataInOps.includes(operationCode)\n    }\n}\n","/**\n * Vendor-agnostic device properties enumeration\n */\nexport enum DeviceProperty {\n    // Exposure properties\n    APERTURE = 'aperture',\n    SHUTTER_SPEED = 'shutterSpeed',\n    ISO = 'iso',\n    EXPOSURE_COMPENSATION = 'exposureCompensation',\n    EXPOSURE_MODE = 'exposureMode',\n    EXPOSURE_METERING_MODE = 'exposureMeteringMode',\n\n    // Focus properties\n    FOCUS_MODE = 'focusMode',\n    FOCUS_AREA = 'focusArea',\n    FOCUS_DISTANCE = 'focusDistance',\n    AF_MODE = 'afMode',\n    AF_AREA_MODE = 'afAreaMode',\n\n    // Capture properties\n    IMAGE_QUALITY = 'imageQuality',\n    IMAGE_SIZE = 'imageSize',\n    IMAGE_FORMAT = 'imageFormat',\n    WHITE_BALANCE = 'whiteBalance',\n    COLOR_SPACE = 'colorSpace',\n    CAPTURE_MODE = 'captureMode',\n    DRIVE_MODE = 'driveMode',\n    BURST_NUMBER = 'burstNumber',\n    BRACKETING_MODE = 'bracketingMode',\n\n    // Flash properties\n    FLASH_MODE = 'flashMode',\n    FLASH_COMPENSATION = 'flashCompensation',\n    FLASH_SYNC_MODE = 'flashSyncMode',\n\n    // Device properties\n    BATTERY_LEVEL = 'batteryLevel',\n    DEVICE_NAME = 'deviceName',\n    SERIAL_NUMBER = 'serialNumber',\n    FIRMWARE_VERSION = 'firmwareVersion',\n    DATE_TIME = 'dateTime',\n\n    // Video properties\n    VIDEO_QUALITY = 'videoQuality',\n    VIDEO_FRAMERATE = 'videoFramerate',\n    AUDIO_RECORDING = 'audioRecording',\n\n    // Other properties\n    CUSTOM_FUNCTION = 'customFunction',\n    COPYRIGHT_INFO = 'copyrightInfo',\n    ARTIST = 'artist',\n}\n\n/**\n * Property value type\n */\nexport type PropertyValue = string | number | boolean | Date | PropertyValue[]\n\n/**\n * Property metadata\n */\nexport interface PropertyMetadata {\n    property: DeviceProperty\n    dataType: DataType\n    unit?: PropertyUnit\n    readable: boolean\n    writable: boolean\n    enumValues?: PropertyEnumValue[]\n    range?: PropertyRange\n}\n\n/**\n * Property enumeration value\n */\nexport interface PropertyEnumValue {\n    value: PropertyValue\n    label: string\n    vendorValue?: unknown\n}\n\n/**\n * Property range\n */\nexport interface PropertyRange {\n    min: PropertyValue\n    max: PropertyValue\n    step?: PropertyValue\n}\n\n/**\n * Data type enumeration\n */\nexport enum DataType {\n    STRING = 'string',\n    NUMBER = 'number',\n    BOOLEAN = 'boolean',\n    DATE = 'date',\n    ARRAY = 'array',\n    FRACTION = 'fraction',\n    ENUM = 'enum',\n}\n\n/**\n * Property unit enumeration\n */\nexport enum PropertyUnit {\n    SECONDS = 'seconds',\n    FRACTION = 'fraction',\n    F_STOP = 'fStop',\n    ISO_VALUE = 'iso',\n    PERCENTAGE = 'percentage',\n    EV = 'ev',\n    METERS = 'meters',\n    KELVIN = 'kelvin',\n    FRAMES_PER_SECOND = 'fps',\n}\n","import { PropertyMapperInterface } from '../interfaces/property-mapper.interface'\nimport { DeviceProperty, PropertyValue } from '../properties/device-properties'\nimport { PTPDeviceProperties } from '../../core/ptp/ptp-constants'\n\n/**\n * Generic property mapper for standard PTP devices\n * Maps vendor-agnostic properties to standard PTP property codes\n */\nexport class GenericPropertyMapper implements PropertyMapperInterface {\n    private readonly genericToVendor = new Map<DeviceProperty, number>([\n        // Standard PTP properties\n        [DeviceProperty.BATTERY_LEVEL, PTPDeviceProperties.BATTERY_LEVEL],\n        [DeviceProperty.WHITE_BALANCE, PTPDeviceProperties.WHITE_BALANCE],\n        [DeviceProperty.APERTURE, PTPDeviceProperties.F_NUMBER],\n        [DeviceProperty.FOCUS_MODE, PTPDeviceProperties.FOCUS_MODE],\n        [DeviceProperty.EXPOSURE_METERING_MODE, PTPDeviceProperties.EXPOSURE_METERING_MODE],\n        [DeviceProperty.FLASH_MODE, PTPDeviceProperties.FLASH_MODE],\n        [DeviceProperty.EXPOSURE_MODE, PTPDeviceProperties.EXPOSURE_PROGRAM_MODE],\n        [DeviceProperty.IMAGE_SIZE, PTPDeviceProperties.IMAGE_SIZE],\n        [DeviceProperty.DATE_TIME, PTPDeviceProperties.DATE_TIME],\n    ])\n\n    private readonly vendorToGeneric = new Map<number, DeviceProperty>()\n\n    constructor() {\n        // Build reverse mapping\n        this.genericToVendor.forEach((vendorCode, genericProp) => {\n            this.vendorToGeneric.set(vendorCode, genericProp)\n        })\n    }\n\n    mapToVendor(property: DeviceProperty): number {\n        const vendorCode = this.genericToVendor.get(property)\n        if (vendorCode === undefined) {\n            throw new Error(`Property ${property} not supported by generic mapper`)\n        }\n        return vendorCode\n    }\n\n    mapFromVendor(vendorCode: number): DeviceProperty | null {\n        return this.vendorToGeneric.get(vendorCode) || null\n    }\n\n    convertValue(property: DeviceProperty, value: PropertyValue): unknown {\n        // Generic implementation - pass through most values\n        switch (property) {\n            case DeviceProperty.APERTURE:\n                // Convert f-stop string to numeric value if needed\n                if (typeof value === 'string' && value.startsWith('f/')) {\n                    const numValue = parseFloat(value.substring(2))\n                    return Math.round(numValue * 100) // Standard PTP uses value * 100\n                }\n                return value\n\n            case DeviceProperty.WHITE_BALANCE:\n                // Map string values to PTP constants if needed\n                if (typeof value === 'string') {\n                    const wbMap: Record<string, number> = {\n                        auto: 0x0002,\n                        daylight: 0x0004,\n                        fluorescent: 0x0005,\n                        incandescent: 0x0006,\n                        flash: 0x0007,\n                        cloudy: 0x8010,\n                        shade: 0x8011,\n                    }\n                    return wbMap[value.toLowerCase()] || 0x0002\n                }\n                return value\n\n            default:\n                return value\n        }\n    }\n\n    parseValue(property: DeviceProperty, rawValue: unknown): PropertyValue {\n        // Generic implementation - parse vendor values back to generic format\n        switch (property) {\n            case DeviceProperty.APERTURE:\n                if (typeof rawValue === 'number') {\n                    return `f/${(rawValue / 100).toFixed(1)}`\n                }\n                return String(rawValue)\n\n            case DeviceProperty.BATTERY_LEVEL:\n                if (typeof rawValue === 'number') {\n                    return rawValue // Return as percentage\n                }\n                return 0\n\n            case DeviceProperty.WHITE_BALANCE:\n                if (typeof rawValue === 'number') {\n                    const wbMap: Record<number, string> = {\n                        0x0002: 'auto',\n                        0x0004: 'daylight',\n                        0x0005: 'fluorescent',\n                        0x0006: 'incandescent',\n                        0x0007: 'flash',\n                        0x8010: 'cloudy',\n                        0x8011: 'shade',\n                    }\n                    return wbMap[rawValue] || 'auto'\n                }\n                return String(rawValue)\n\n            default:\n                // Return as-is for unknown properties\n                if (rawValue === null || rawValue === undefined) {\n                    return ''\n                }\n                if (typeof rawValue === 'object' && rawValue instanceof Uint8Array) {\n                    // Try to parse as string if it's a byte array\n                    const decoder = new TextDecoder()\n                    try {\n                        return decoder.decode(rawValue)\n                    } catch {\n                        return String(rawValue)\n                    }\n                }\n                return rawValue as PropertyValue\n        }\n    }\n\n    isSupported(property: DeviceProperty): boolean {\n        return this.genericToVendor.has(property)\n    }\n\n    getSupportedProperties(): DeviceProperty[] {\n        return Array.from(this.genericToVendor.keys())\n    }\n}\n","/**\n * Image information interface\n */\nexport interface ImageInfo {\n    handle: number\n    storageId: number\n    objectFormat: number\n    protectionStatus: number\n    objectCompressedSize: number\n    thumbFormat: number\n    thumbCompressedSize: number\n    thumbPixWidth: number\n    thumbPixHeight: number\n    imagePixWidth: number\n    imagePixHeight: number\n    imageBitDepth: number\n    parentObject: number\n    associationType: number\n    associationDescription: number\n    sequenceNumber: number\n    filename: string\n    captureDate: Date\n    modificationDate: Date\n    keywords?: string\n}\n\n/**\n * Image data interface\n */\nexport interface ImageData {\n    data: Uint8Array\n    format: ImageFormat\n    width: number\n    height: number\n    handle?: number\n    filename?: string\n    thumbnailData?: Uint8Array\n}\n\n/**\n * Image format enumeration\n */\nexport enum ImageFormat {\n    JPEG = 'jpeg',\n    RAW = 'raw',\n    TIFF = 'tiff',\n    BMP = 'bmp',\n    PNG = 'png',\n    HEIF = 'heif',\n    DNG = 'dng',\n    ARW = 'arw',\n    CR2 = 'cr2',\n    NEF = 'nef',\n}\n","import { ProtocolInterface } from '../../core/interfaces/protocol.interface'\nimport { PropertyMapperInterface } from '../interfaces/property-mapper.interface'\nimport { CameraInterface, PropertyDescriptor, CameraInfo, StorageInfo } from '../interfaces/camera.interface'\nimport { DeviceProperty, PropertyValue } from '../properties/device-properties'\nimport { ImageInfo, ImageData, ImageFormat } from '../interfaces/image.interface'\nimport { LiveViewFrame } from '../interfaces/liveview.interface'\nimport { PTPOperations, PTPResponses } from '../../core/ptp/ptp-constants'\n\n/**\n * Generic PTP camera implementation\n * Provides standard PTP operations with vendor-agnostic property mapping\n */\nexport class GenericPTPCamera implements CameraInterface {\n    protected sessionId = 1\n    protected connected = false\n    protected liveViewActive = false\n\n    constructor(\n        protected readonly protocol: ProtocolInterface,\n        protected readonly propertyMapper: PropertyMapperInterface\n    ) {}\n\n    async connect(): Promise<void> {\n        await this.protocol.openSession(this.sessionId)\n        this.connected = true\n    }\n\n    async disconnect(): Promise<void> {\n        if (this.liveViewActive) {\n            await this.disableLiveView()\n        }\n        await this.protocol.closeSession()\n        this.connected = false\n    }\n\n    isConnected(): boolean {\n        return this.connected\n    }\n\n    async captureImage(): Promise<void> {\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.INITIATE_CAPTURE,\n            parameters: [0, 0],\n            hasDataPhase: false,\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Capture failed: 0x${response.code.toString(16)}`)\n        }\n    }\n\n    async getDeviceProperty(property: DeviceProperty): Promise<PropertyValue> {\n        const vendorCode = this.propertyMapper.mapToVendor(property)\n\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_DEVICE_PROP_VALUE,\n            parameters: [vendorCode],\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to get property ${property}: 0x${response.code.toString(16)}`)\n        }\n\n        if (!response.data) {\n            throw new Error(`No data received for property ${property}`)\n        }\n\n        return this.propertyMapper.parseValue(property, response.data)\n    }\n\n    async setDeviceProperty(property: DeviceProperty, value: PropertyValue): Promise<void> {\n        const vendorCode = this.propertyMapper.mapToVendor(property)\n        const vendorValue = this.propertyMapper.convertValue(property, value)\n\n        // Convert value to Uint8Array for sending\n        const data = this.encodePropertyValue(vendorValue)\n\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.SET_DEVICE_PROP_VALUE,\n            parameters: [vendorCode],\n            hasDataPhase: true,\n            data,\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to set property ${property}: 0x${response.code.toString(16)}`)\n        }\n    }\n\n    async getPropertyDescriptor(property: DeviceProperty): Promise<PropertyDescriptor> {\n        const vendorCode = this.propertyMapper.mapToVendor(property)\n\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_DEVICE_PROP_DESC,\n            parameters: [vendorCode],\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to get property descriptor: 0x${response.code.toString(16)}`)\n        }\n\n        // Parse descriptor from response data\n        return this.parsePropertyDescriptor(property, response.data!)\n    }\n\n    async enableLiveView(): Promise<void> {\n        // Generic implementation - vendors may override\n        this.liveViewActive = true\n    }\n\n    async disableLiveView(): Promise<void> {\n        // Generic implementation - vendors may override\n        this.liveViewActive = false\n    }\n\n    async getLiveViewFrame(): Promise<LiveViewFrame> {\n        if (!this.liveViewActive) {\n            throw new Error('Live view is not active')\n        }\n\n        // Generic implementation - vendors will override\n        throw new Error('Live view not implemented for generic camera')\n    }\n\n    isLiveViewActive(): boolean {\n        return this.liveViewActive\n    }\n\n    async listImages(): Promise<ImageInfo[]> {\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_OBJECT_HANDLES,\n            parameters: [0xffffffff, 0, 0], // All storage, all formats, root\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to list images: 0x${response.code.toString(16)}`)\n        }\n\n        // Parse handles from response\n        const handles = this.parseHandles(response.data!)\n        const images: ImageInfo[] = []\n\n        for (const handle of handles) {\n            const info = await this.getObjectInfo(handle)\n            if (info) {\n                images.push(info)\n            }\n        }\n\n        return images\n    }\n\n    async downloadImage(handle: number): Promise<ImageData> {\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_OBJECT,\n            parameters: [handle],\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to download image: 0x${response.code.toString(16)}`)\n        }\n\n        // Skip PTP header if present\n        const data = response.data!.length > 12 ? response.data!.slice(12) : response.data!\n\n        return {\n            data,\n            format: ImageFormat.JPEG, // TODO: Detect from object info\n            width: 0, // TODO: Parse from object info\n            height: 0,\n            handle,\n        }\n    }\n\n    async deleteImage(handle: number): Promise<void> {\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.DELETE_OBJECT,\n            parameters: [handle, 0], // Handle and format (0 = don't care)\n            hasDataPhase: false,\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to delete image: 0x${response.code.toString(16)}`)\n        }\n    }\n\n    async getCameraInfo(): Promise<CameraInfo> {\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_DEVICE_INFO,\n            parameters: [],\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to get device info: 0x${response.code.toString(16)}`)\n        }\n\n        return this.parseDeviceInfo(response.data!)\n    }\n\n    async getStorageInfo(): Promise<StorageInfo[]> {\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_STORAGE_IDS,\n            parameters: [],\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to get storage IDs: 0x${response.code.toString(16)}`)\n        }\n\n        const storageIds = this.parseStorageIds(response.data!)\n        const storageInfos: StorageInfo[] = []\n\n        for (const id of storageIds) {\n            const info = await this.getStorageInfoById(id)\n            if (info) {\n                storageInfos.push(info)\n            }\n        }\n\n        return storageInfos\n    }\n\n    // Protected helper methods\n\n    protected encodePropertyValue(value: unknown): Uint8Array {\n        // Simple encoding for basic types\n        if (typeof value === 'number') {\n            const data = new Uint8Array(4)\n            new DataView(data.buffer).setUint32(0, value, true)\n            return data\n        } else if (value instanceof Uint8Array) {\n            return value\n        } else {\n            throw new Error(`Cannot encode property value of type ${typeof value}`)\n        }\n    }\n\n    protected parsePropertyDescriptor(property: DeviceProperty, data: Uint8Array): PropertyDescriptor {\n        // Basic parsing - vendors may override for specific formats\n        const view = new DataView(data.buffer, data.byteOffset)\n        let offset = 0\n\n        view.getUint16(offset, true) // propertyCode - read but not used\n        offset += 2\n        const dataType = view.getUint16(offset, true)\n        offset += 2\n        const getSet = view.getUint8(offset)\n        offset += 1\n\n        // TODO: Parse rest of descriptor including default value, current value, form flag, etc.\n\n        return {\n            property,\n            dataType,\n            getSet,\n            factoryDefault: '', // Use empty string instead of null\n            currentValue: '', // Use empty string instead of null\n            formFlag: 0,\n        }\n    }\n\n    protected parseHandles(data: Uint8Array): number[] {\n        const view = new DataView(data.buffer, data.byteOffset)\n        const count = view.getUint32(0, true)\n        const handles: number[] = []\n\n        for (let i = 0; i < count; i++) {\n            handles.push(view.getUint32(4 + i * 4, true))\n        }\n\n        return handles\n    }\n\n    protected async getObjectInfo(handle: number): Promise<ImageInfo | null> {\n        try {\n            const response = await this.protocol.sendOperation({\n                code: PTPOperations.GET_OBJECT_INFO,\n                parameters: [handle],\n            })\n\n            if (response.code !== PTPResponses.OK) {\n                return null\n            }\n\n            // Parse object info\n            const view = new DataView(response.data!.buffer, response.data!.byteOffset)\n            let offset = 0\n\n            const storageId = view.getUint32(offset, true)\n            offset += 4\n            const objectFormat = view.getUint16(offset, true)\n            offset += 2\n            view.getUint16(offset, true) // protectionStatus - read but not used\n            offset += 2\n            const compressedSize = view.getUint32(offset, true)\n            offset += 4\n\n            // Skip thumb format, compressed size, width, height, etc.\n            // TODO: Parse these fields properly\n\n            return {\n                handle,\n                storageId,\n                objectFormat,\n                protectionStatus: 0,\n                objectCompressedSize: compressedSize,\n                thumbFormat: 0,\n                thumbCompressedSize: 0,\n                thumbPixWidth: 0,\n                thumbPixHeight: 0,\n                imagePixWidth: 0,\n                imagePixHeight: 0,\n                imageBitDepth: 0,\n                parentObject: 0,\n                associationType: 0,\n                associationDescription: 0,\n                sequenceNumber: 0,\n                filename: `IMG_${handle}.jpg`,\n                captureDate: new Date(),\n                modificationDate: new Date(),\n            }\n        } catch {\n            return null\n        }\n    }\n\n    protected parseDeviceInfo(_data: Uint8Array): CameraInfo {\n        // Basic parsing - this is a complex structure\n        // TODO: Implement full parsing\n        return {\n            manufacturer: 'Generic',\n            model: 'PTP Camera',\n            version: '1.0',\n            serialNumber: '000000',\n            operationsSupported: [],\n            eventsSupported: [],\n            devicePropertiesSupported: [],\n            captureFormats: [],\n            imageFormats: [],\n        }\n    }\n\n    protected parseStorageIds(data: Uint8Array): number[] {\n        const view = new DataView(data.buffer, data.byteOffset)\n        const count = view.getUint32(0, true)\n        const ids: number[] = []\n\n        for (let i = 0; i < count; i++) {\n            ids.push(view.getUint32(4 + i * 4, true))\n        }\n\n        return ids\n    }\n\n    protected async getStorageInfoById(storageId: number): Promise<StorageInfo | null> {\n        try {\n            const response = await this.protocol.sendOperation({\n                code: PTPOperations.GET_STORAGE_INFO,\n                parameters: [storageId],\n            })\n\n            if (response.code !== PTPResponses.OK) {\n                return null\n            }\n\n            // Parse storage info\n            const view = new DataView(response.data!.buffer, response.data!.byteOffset)\n            let offset = 0\n\n            const storageType = view.getUint16(offset, true)\n            offset += 2\n            const filesystemType = view.getUint16(offset, true)\n            offset += 2\n            const accessCapability = view.getUint16(offset, true)\n            offset += 2\n            const maxCapacity = view.getBigUint64(offset, true)\n            offset += 8\n            const freeSpaceInBytes = view.getBigUint64(offset, true)\n            offset += 8\n            const freeSpaceInImages = view.getUint32(offset, true)\n            offset += 4\n\n            return {\n                storageId,\n                storageType,\n                filesystemType,\n                accessCapability,\n                maxCapacity,\n                freeSpaceInBytes,\n                freeSpaceInImages,\n                storageDescription: '',\n                volumeLabel: '',\n            }\n        } catch {\n            return null\n        }\n    }\n}\n","import { PropertyMapperInterface } from '../../interfaces/property-mapper.interface'\nimport { DeviceProperty, PropertyValue } from '../../properties/device-properties'\nimport { SonyDeviceProperties, formatFNumber, formatShutterSpeed, formatISO } from './sony-constants'\n\n/**\n * Sony property mapper\n * Maps vendor-agnostic properties to Sony-specific property codes\n */\nexport class SonyPropertyMapper implements PropertyMapperInterface {\n    private readonly genericToVendor = new Map<DeviceProperty, number>([\n        // Exposure properties - using exact codes from old architecture\n        [DeviceProperty.APERTURE, SonyDeviceProperties.F_NUMBER], // 0x5007\n        [DeviceProperty.SHUTTER_SPEED, SonyDeviceProperties.SHUTTER_SPEED], // 0xD20D\n        [DeviceProperty.ISO, SonyDeviceProperties.ISO_SENSITIVITY], // 0xD21E\n\n        // Other standard properties\n        [DeviceProperty.BATTERY_LEVEL, SonyDeviceProperties.BATTERY_LEVEL],\n        [DeviceProperty.WHITE_BALANCE, SonyDeviceProperties.WHITE_BALANCE],\n        [DeviceProperty.FOCUS_MODE, SonyDeviceProperties.FOCUS_MODE],\n        [DeviceProperty.EXPOSURE_METERING_MODE, SonyDeviceProperties.EXPOSURE_METERING_MODE],\n        [DeviceProperty.FLASH_MODE, SonyDeviceProperties.FLASH_MODE],\n        [DeviceProperty.EXPOSURE_MODE, SonyDeviceProperties.EXPOSURE_PROGRAM_MODE],\n        [DeviceProperty.IMAGE_SIZE, SonyDeviceProperties.IMAGE_SIZE],\n        [DeviceProperty.DATE_TIME, SonyDeviceProperties.DATE_TIME],\n    ])\n\n    private readonly vendorToGeneric = new Map<number, DeviceProperty>([\n        [SonyDeviceProperties.F_NUMBER, DeviceProperty.APERTURE],\n        [SonyDeviceProperties.SHUTTER_SPEED, DeviceProperty.SHUTTER_SPEED],\n        [SonyDeviceProperties.ISO_SENSITIVITY, DeviceProperty.ISO],\n        // Also map alternative ISO properties to the same generic property\n        [SonyDeviceProperties.ISO_SENSITIVITY_ALT1, DeviceProperty.ISO],\n        [SonyDeviceProperties.ISO_SENSITIVITY_ALT2, DeviceProperty.ISO],\n        [SonyDeviceProperties.ISO_SENSITIVITY_ALT3, DeviceProperty.ISO],\n    ])\n\n    mapToVendor(property: DeviceProperty): number {\n        const vendorCode = this.genericToVendor.get(property)\n        if (vendorCode === undefined) {\n            throw new Error(`Property ${property} not supported by Sony`)\n        }\n        return vendorCode\n    }\n\n    mapFromVendor(vendorCode: number): DeviceProperty | null {\n        return this.vendorToGeneric.get(vendorCode) || null\n    }\n\n    convertValue(property: DeviceProperty, value: PropertyValue): unknown {\n        switch (property) {\n            case DeviceProperty.SHUTTER_SPEED:\n                return this.parseShutterSpeed(String(value))\n\n            case DeviceProperty.APERTURE:\n                return this.parseAperture(String(value))\n\n            case DeviceProperty.ISO:\n                return this.parseISO(value)\n\n            default:\n                return value\n        }\n    }\n\n    parseValue(property: DeviceProperty, rawValue: unknown): PropertyValue {\n        switch (property) {\n            case DeviceProperty.SHUTTER_SPEED:\n                if (rawValue instanceof Uint8Array) {\n                    return this.formatShutterSpeedFromBytes(rawValue)\n                }\n                return formatShutterSpeed(Number(rawValue))\n\n            case DeviceProperty.APERTURE:\n                if (typeof rawValue === 'number') {\n                    return formatFNumber(rawValue)\n                }\n                return String(rawValue)\n\n            case DeviceProperty.ISO:\n                if (typeof rawValue === 'number') {\n                    return formatISO(rawValue)\n                }\n                return String(rawValue)\n\n            default:\n                if (rawValue === null || rawValue === undefined) {\n                    return ''\n                }\n                return rawValue as PropertyValue\n        }\n    }\n\n    isSupported(property: DeviceProperty): boolean {\n        return this.genericToVendor.has(property)\n    }\n\n    getSupportedProperties(): DeviceProperty[] {\n        return Array.from(this.genericToVendor.keys())\n    }\n\n    // Private helper methods\n\n    private parseShutterSpeed(value: string): Uint8Array {\n        // Parse \"1/250\" format to Sony's fractional format\n        const data = new Uint8Array(8)\n        const view = new DataView(data.buffer)\n\n        if (value === 'BULB') {\n            view.setUint32(0, 0x00000000, true)\n            view.setUint32(4, 0x00000000, true)\n            return data\n        }\n\n        if (value.startsWith('1/')) {\n            const denominator = parseInt(value.substring(2))\n            view.setUint32(0, 1, true) // Numerator\n            view.setUint32(4, denominator, true) // Denominator\n        } else {\n            // Handle full seconds like \"2\"\n            const seconds = parseFloat(value.replace('\"', ''))\n            view.setUint32(0, seconds * 10000, true) // Sony uses 1/10000 seconds\n            view.setUint32(4, 10000, true)\n        }\n\n        return data\n    }\n\n    private parseAperture(value: string): Uint8Array {\n        // Convert from \"f/2.8\" to Sony's format (value * 100)\n        const data = new Uint8Array(2)\n        const view = new DataView(data.buffer)\n\n        if (value.startsWith('f/')) {\n            const fNumber = parseFloat(value.substring(2))\n            view.setUint16(0, Math.round(fNumber * 100), true)\n        }\n\n        return data\n    }\n\n    private parseISO(value: PropertyValue): number {\n        if (typeof value === 'string') {\n            const lowerValue = value.toLowerCase()\n\n            if (lowerValue === 'auto' || lowerValue === 'iso auto') {\n                return 0x00ffffff // ISO AUTO\n            }\n\n            // Extract numeric ISO value from string like \"ISO 400\"\n            const match = value.match(/\\d+/)\n            if (match) {\n                return parseInt(match[0])\n            }\n        }\n\n        return Number(value)\n    }\n\n    private formatShutterSpeedFromBytes(rawValue: Uint8Array): string {\n        if (rawValue.length >= 8) {\n            const view = new DataView(rawValue.buffer, rawValue.byteOffset)\n            const numerator = view.getUint32(0, true)\n            const denominator = view.getUint32(4, true)\n\n            if (numerator === 0 && denominator === 0) {\n                return 'BULB'\n            }\n\n            if (numerator === 1 && denominator > 1) {\n                return `1/${denominator}`\n            }\n\n            if (denominator !== 0) {\n                const seconds = numerator / denominator\n                return seconds >= 1 ? `${seconds}\"` : `1/${Math.round(1 / seconds)}`\n            }\n        }\n\n        return 'Unknown'\n    }\n}\n","import { ProtocolInterface } from '../../../core/interfaces/protocol.interface'\nimport { SonyOperations, SonyConstants, SDIOPhases, SDIOPhase } from './sony-constants'\nimport { PTPResponses } from '../../../core/ptp/ptp-constants'\n\n/**\n * Interface for Sony authentication\n */\nexport interface SonyAuthenticatorInterface {\n    authenticate(protocol: ProtocolInterface): Promise<void>\n}\n\n/**\n * Sony camera authenticator\n * Handles the Sony-specific authentication handshake\n */\nexport class SonyAuthenticator implements SonyAuthenticatorInterface {\n    private deviceInfo: any = null\n\n    async authenticate(protocol: ProtocolInterface): Promise<void> {\n        // Phase 1: Initial handshake\n        console.log('Sony Auth: Starting Phase 1 - Initial handshake')\n        await this.sdioConnect(protocol, SDIOPhases.INITIAL_HANDSHAKE)\n        console.log('Sony Auth: Phase 1 complete')\n\n        // Phase 2: Capability exchange\n        console.log('Sony Auth: Starting Phase 2 - Capability exchange')\n        await this.sdioConnect(protocol, SDIOPhases.CAPABILITY_EXCHANGE)\n        console.log('Sony Auth: Phase 2 complete')\n\n        // Get extended device info\n        console.log('Sony Auth: Getting extended device info')\n        await this.getExtDeviceInfo(protocol)\n        console.log('Sony Auth: Extended device info retrieved')\n\n        // Phase 3: Final authentication\n        console.log('Sony Auth: Starting Phase 3 - Final authentication')\n        await this.sdioConnect(protocol, SDIOPhases.FINAL_AUTHENTICATION)\n        console.log('Sony Auth: Phase 3 complete - Authentication successful!')\n    }\n\n    private async sdioConnect(protocol: ProtocolInterface, phase: SDIOPhase): Promise<void> {\n        console.log(`Sony Auth: Sending SDIO_CONNECT for phase ${phase}`)\n        const response = await protocol.sendOperation({\n            code: SonyOperations.SDIO_CONNECT,\n            parameters: [phase, 0, 0], // Phase, KeyCode1, KeyCode2\n            hasDataPhase: true, // Expect data in response\n        })\n        console.log(`Sony Auth: SDIO_CONNECT response: 0x${response.code.toString(16)}`)\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`SDIO Connect Phase ${phase} failed: 0x${response.code.toString(16)}`)\n        }\n    }\n\n    private async getExtDeviceInfo(protocol: ProtocolInterface): Promise<void> {\n        const response = await protocol.sendOperation({\n            code: SonyOperations.SDIO_GET_EXT_DEVICE_INFO,\n            parameters: [SonyConstants.PROTOCOL_VERSION, SonyConstants.DEVICE_PROPERTY_OPTION],\n            hasDataPhase: true, // Expect device info data\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Get extended device info failed: 0x${response.code.toString(16)}`)\n        }\n\n        // Parse device info (simplified)\n        if (response.data && response.data.length > 0) {\n            const view = new DataView(response.data.buffer, response.data.byteOffset)\n            const version = view.getUint16(0, true)\n\n            // Store for later use\n            this.deviceInfo = { version, raw: response.data }\n        }\n    }\n\n    getDeviceInfo(): any {\n        return this.deviceInfo\n    }\n}\n","/**\n * Live view frame interface\n */\nexport interface LiveViewFrame {\n    data: Uint8Array\n    width: number\n    height: number\n    format: FrameFormat\n    timestamp: number\n    metadata?: FrameMetadata\n}\n\n/**\n * Frame format enumeration\n */\nexport enum FrameFormat {\n    JPEG = 'jpeg',\n    YUV = 'yuv',\n    RGB = 'rgb',\n    RAW = 'raw',\n}\n\n/**\n * Frame metadata\n */\nexport interface FrameMetadata {\n    focusInfo?: FocusInfo\n    exposureInfo?: ExposureInfo\n    whiteBalance?: WhiteBalanceInfo\n    faces?: FaceInfo[]\n}\n\n/**\n * Focus information\n */\nexport interface FocusInfo {\n    focusMode: string\n    focusAreas: FocusArea[]\n    focusStatus: FocusStatus\n}\n\n/**\n * Focus area\n */\nexport interface FocusArea {\n    x: number\n    y: number\n    width: number\n    height: number\n    active: boolean\n}\n\n/**\n * Focus status enumeration\n */\nexport enum FocusStatus {\n    IDLE = 'idle',\n    FOCUSING = 'focusing',\n    FOCUSED = 'focused',\n    FAILED = 'failed',\n}\n\n/**\n * Exposure information\n */\nexport interface ExposureInfo {\n    aperture: string\n    shutterSpeed: string\n    iso: number\n    exposureCompensation: string\n    exposureMode: string\n}\n\n/**\n * White balance information\n */\nexport interface WhiteBalanceInfo {\n    mode: string\n    colorTemperature?: number\n    tint?: number\n}\n\n/**\n * Face detection information\n */\nexport interface FaceInfo {\n    x: number\n    y: number\n    width: number\n    height: number\n    confidence: number\n    id?: number\n}\n","import { ProtocolInterface } from '../../../core/interfaces/protocol.interface'\nimport { GenericPTPCamera } from '../../generic/generic-ptp-camera'\nimport { SonyPropertyMapper } from './sony-property-mapper'\nimport { SonyAuthenticator, SonyAuthenticatorInterface } from './sony-authenticator'\nimport { SonyOperations, SonyDeviceProperties, SonyConstants } from './sony-constants'\nimport { DeviceProperty, PropertyValue } from '../../properties/device-properties'\nimport { LiveViewFrame, FrameFormat } from '../../interfaces/liveview.interface'\nimport { ImageData, ImageFormat } from '../../interfaces/image.interface'\nimport { PTPOperations, PTPResponses } from '../../../core/ptp/ptp-constants'\n\n// Data type constants\nconst PTPDataTypes = {\n    INT8: 0x0001,\n    UINT8: 0x0002,\n    INT16: 0x0003,\n    UINT16: 0x0004,\n    INT32: 0x0005,\n    UINT32: 0x0006,\n    INT64: 0x0007,\n    UINT64: 0x0008,\n    INT128: 0x000a,\n    UINT128: 0x000b,\n    STRING: 0xffff,\n}\n\n// Sony property info interface\ninterface SonyPropertyInfo {\n    propertyCode: number\n    dataType: number\n    getSet: number\n    isEnabled: number\n    currentValue: any\n    formFlag: number\n    nextOffset: number\n    enumValuesSet?: any[]\n    enumValuesGetSet?: any[]\n}\n\n/**\n * Read a property value from a DataView based on PTP data type\n */\nfunction readValue(view: DataView, offset: number, dataType: number): { value: any; size: number } {\n    switch (dataType) {\n        case PTPDataTypes.INT8:\n            return { value: view.getInt8(offset), size: 1 }\n        case PTPDataTypes.UINT8:\n            return { value: view.getUint8(offset), size: 1 }\n        case PTPDataTypes.INT16:\n            return { value: view.getInt16(offset, true), size: 2 }\n        case PTPDataTypes.UINT16:\n            return { value: view.getUint16(offset, true), size: 2 }\n        case PTPDataTypes.INT32:\n            return { value: view.getInt32(offset, true), size: 4 }\n        case PTPDataTypes.UINT32:\n            return { value: view.getUint32(offset, true), size: 4 }\n        case PTPDataTypes.INT64:\n            return { value: Number(view.getBigInt64(offset, true)), size: 8 }\n        case PTPDataTypes.UINT64:\n            return { value: Number(view.getBigUint64(offset, true)), size: 8 }\n        case PTPDataTypes.INT128:\n        case PTPDataTypes.UINT128:\n            return { value: BigInt(0), size: 16 } // BigInt zero for 128-bit\n        case PTPDataTypes.STRING: {\n            // Read null-terminated UTF-16LE string\n            const numChars = view.getUint8(offset)\n            offset += 1\n            let str = ''\n            for (let i = 0; i < numChars; i++) {\n                const char = view.getUint16(offset, true)\n                if (char === 0) break\n                str += String.fromCharCode(char)\n                offset += 2\n            }\n            return { value: str, size: 1 + numChars * 2 }\n        }\n        default:\n            // Handle arrays\n            if ((dataType & 0x4000) === 0x4000) {\n                const count = view.getUint32(offset, true)\n                offset += 4\n                const baseType = dataType & 0x3fff\n                const values = []\n                let totalSize = 4\n                for (let i = 0; i < count; i++) {\n                    const result = readValue(view, offset, baseType)\n                    values.push(result.value)\n                    offset += result.size\n                    totalSize += result.size\n                }\n                return { value: values, size: totalSize }\n            }\n            return { value: null, size: 4 }\n    }\n}\n\n/**\n * Sony camera implementation\n * Extends GenericPTPCamera with Sony-specific functionality\n */\nexport class SonyCamera extends GenericPTPCamera {\n    private readonly sonyAuthenticator: SonyAuthenticatorInterface\n    private lastLiveViewTime = 0\n    private cachedProperties: Map<number, any> | null = null\n    private propertiesLastFetched = 0\n    private readonly PROPERTIES_CACHE_TTL = 5000 // 5 seconds\n\n    constructor(protocol: ProtocolInterface, sonyAuthenticator?: SonyAuthenticatorInterface) {\n        super(protocol, new SonyPropertyMapper())\n        this.sonyAuthenticator = sonyAuthenticator || new SonyAuthenticator()\n    }\n\n    async connect(): Promise<void> {\n        // Try to close any existing session first\n        try {\n            await this.protocol.closeSession()\n        } catch {\n            // Ignore if no session was open\n        }\n\n        await this.protocol.openSession(this.sessionId)\n        await this.sonyAuthenticator.authenticate(this.protocol)\n        this.connected = true\n    }\n\n    async captureImage(): Promise<void> {\n        // Configure camera for shooting\n        await this.configureStillShooting()\n        await this.sleep(500)\n\n        // Execute 4-step shooting sequence\n        await this.executeShootingSequence()\n    }\n\n    async enableLiveView(): Promise<void> {\n        // Enable live view using control command\n        const controlData = new Uint8Array(2)\n        new DataView(controlData.buffer).setUint16(0, SonyConstants.LIVE_VIEW_ENABLE, true)\n\n        await this.protocol.sendOperation({\n            code: SonyOperations.CONTROL_DEVICE_PROPERTY,\n            parameters: [SonyDeviceProperties.LIVE_VIEW_CONTROL],\n            hasDataPhase: true,\n            data: controlData,\n        })\n\n        // Wait for live view to activate\n        await this.sleep(1000)\n        this.liveViewActive = true\n    }\n\n    async disableLiveView(): Promise<void> {\n        const controlData = new Uint8Array(2)\n        new DataView(controlData.buffer).setUint16(0, SonyConstants.LIVE_VIEW_DISABLE, true)\n\n        await this.protocol.sendOperation({\n            code: SonyOperations.CONTROL_DEVICE_PROPERTY,\n            parameters: [SonyDeviceProperties.LIVE_VIEW_CONTROL],\n            hasDataPhase: true,\n            data: controlData,\n        })\n\n        this.liveViewActive = false\n    }\n\n    async getLiveViewFrame(): Promise<LiveViewFrame> {\n        if (!this.liveViewActive) {\n            throw new Error('Live view is not active')\n        }\n\n        // Respect 30fps maximum (33ms minimum between requests)\n        const now = Date.now()\n        const timeSinceLastRequest = now - this.lastLiveViewTime\n        if (timeSinceLastRequest < 33) {\n            const waitTime = 33 - timeSinceLastRequest\n            await this.sleep(waitTime)\n        }\n        this.lastLiveViewTime = Date.now()\n\n        // Get object info for live view image\n        const infoResponse = await this.protocol.sendOperation({\n            code: PTPOperations.GET_OBJECT_INFO,\n            parameters: [SonyConstants.LIVE_VIEW_IMAGE_HANDLE],\n        })\n\n        const width = 1920\n        const height = 1080\n\n        if (infoResponse.data && infoResponse.data.length > 12) {\n            const view = new DataView(infoResponse.data.buffer, infoResponse.data.byteOffset + 12)\n            const imageSize = view.getUint32(8, true)\n            console.log(`Image size: ${imageSize} bytes`)\n\n            // Don't read width/height from info - they're not reliable\n            // We'll use defaults or get them from the actual JPEG\n        }\n\n        // Get the actual live view image with retry on Access_Denied\n        let imageData: Uint8Array | null = null\n        let retryCount = 0\n        const maxRetries = 3\n\n        while (!imageData && retryCount < maxRetries) {\n            const response = await this.protocol.sendOperation({\n                code: PTPOperations.GET_OBJECT,\n                parameters: [SonyConstants.LIVE_VIEW_IMAGE_HANDLE],\n                maxDataLength: 5 * 1024 * 1024, // 5MB buffer for live view\n            })\n\n            if (response.code === SonyConstants.ACCESS_DENIED) {\n                retryCount++\n                await this.sleep(50)\n                continue\n            }\n\n            if (response.code === PTPResponses.OK && response.data) {\n                imageData = response.data\n                break\n            }\n\n            retryCount++\n        }\n\n        if (!imageData) {\n            throw new Error('Failed to get live view image after retries')\n        }\n\n        // The imageData is already parsed without PTP container header\n        const liveViewDataset = imageData\n        console.log(`Live view dataset length: ${liveViewDataset.length}`)\n        if (liveViewDataset.length > 20) {\n            console.log(\n                `First 20 bytes of dataset: ${Array.from(liveViewDataset.slice(0, 20))\n                    .map(b => `0x${b.toString(16).padStart(2, '0')}`)\n                    .join(' ')}`\n            )\n        }\n\n        const parsed = this.parseLiveViewDataset(liveViewDataset)\n\n        if (!parsed) {\n            throw new Error('Failed to parse LiveView Dataset')\n        }\n\n        // It's OK if the JPEG is empty - camera might not be ready\n        if (parsed.jpeg.length === 0) {\n            console.log('Live view frame is empty (camera may not be ready)')\n            return {\n                data: new Uint8Array(0),\n                width: width || 1920,\n                height: height || 1080,\n                format: FrameFormat.JPEG,\n                timestamp: Date.now(),\n            }\n        }\n\n        return {\n            data: parsed.jpeg,\n            width: width || parsed.width || 1920,\n            height: height || parsed.height || 1080,\n            format: FrameFormat.JPEG,\n            timestamp: Date.now(),\n        }\n    }\n\n    // Sony-specific methods\n\n    async setOSDMode(enabled: boolean): Promise<boolean> {\n        try {\n            const osdValue = enabled ? 0x01 : 0x00\n            const osdData = new Uint8Array(1)\n            osdData[0] = osdValue\n\n            // Send SET_DEVICE_PROPERTY_VALUE command with data\n            await this.setPropertyValue(SonyDeviceProperties.OSD_IMAGE_MODE, osdData)\n\n            return true\n        } catch (error) {\n            console.log(`Failed to set OSD mode: ${String(error)}`)\n            return false\n        }\n    }\n\n    async getOSDImage(): Promise<ImageData> {\n        // Ensure OSD mode is enabled\n        await this.setOSDMode(true)\n        await this.sleep(100)\n\n        // Send GetOSDImage command\n        const response = await this.protocol.sendOperation({\n            code: SonyOperations.SDIO_GET_OSD_IMAGE,\n            parameters: [],\n            hasDataPhase: true,\n            maxDataLength: 512 * 1024, // 512KB buffer for OSD images\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`GetOSDImage failed with code 0x${response.code.toString(16)}`)\n        }\n\n        if (!response.data || response.data.length === 0) {\n            throw new Error('No OSD image data received')\n        }\n\n        // The data is already parsed without PTP container header\n        const pngData = this.parseOSDDataset(response.data)\n\n        if (!pngData) {\n            throw new Error('Failed to extract PNG from OSD data')\n        }\n\n        return {\n            data: pngData,\n            format: ImageFormat.PNG,\n            width: 0, // Will be determined from PNG\n            height: 0,\n        }\n    }\n\n    async getCameraSettings(): Promise<{\n        aperture: string\n        shutterSpeed: string\n        iso: string\n    }> {\n        // Ensure we have fresh property data\n        await this.refreshPropertiesIfNeeded()\n\n        if (!this.cachedProperties) {\n            throw new Error('Failed to get camera settings')\n        }\n\n        // Extract values from cached properties\n        const aperture = this.extractPropertyValue(SonyDeviceProperties.F_NUMBER)\n        const shutterSpeed = this.extractPropertyValue(SonyDeviceProperties.SHUTTER_SPEED)\n        const iso = this.extractPropertyValue(SonyDeviceProperties.ISO_SENSITIVITY)\n\n        return {\n            aperture: aperture ? this.formatAperture(aperture) : 'Unknown',\n            shutterSpeed: shutterSpeed ? this.formatShutterSpeed(shutterSpeed) : 'Unknown',\n            iso: iso ? this.formatISO(iso) : 'Unknown',\n        }\n    }\n\n    /**\n     * Override getDeviceProperty to use Sony's approach\n     */\n    async getDeviceProperty(property: DeviceProperty): Promise<PropertyValue> {\n        // Refresh properties if needed\n        await this.refreshPropertiesIfNeeded()\n\n        if (!this.cachedProperties) {\n            throw new Error('Failed to get device properties')\n        }\n\n        // Map generic property to Sony property code\n        const vendorCode = this.propertyMapper.mapToVendor(property)\n        console.log(`Looking for property ${property} with vendor code 0x${vendorCode.toString(16)}`)\n\n        // Extract value from cached properties\n        const rawValue = this.extractPropertyValue(vendorCode)\n\n        if (rawValue === undefined) {\n            // Return a default value for missing properties\n            console.log(`Warning: Property ${property} (0x${vendorCode.toString(16)}) not found, using default`)\n\n            // Return sensible defaults based on property type\n            switch (property) {\n                case DeviceProperty.SHUTTER_SPEED:\n                    return '1/60' // Default shutter speed\n                case DeviceProperty.APERTURE:\n                    return 'f/2.8' // Default aperture\n                case DeviceProperty.ISO:\n                    return 'AUTO' // Default ISO\n                default:\n                    return 'N/A'\n            }\n        }\n\n        // Parse and return the value\n        return this.propertyMapper.parseValue(property, rawValue)\n    }\n\n    async getPhoto(): Promise<ImageData & { filename: string }> {\n        // Give camera a moment to finalize the capture\n        await this.sleep(1000)\n\n        // Get object info\n        const infoResponse = await this.protocol.sendOperation({\n            code: PTPOperations.GET_OBJECT_INFO,\n            parameters: [SonyConstants.RECENT_IMAGE_HANDLE],\n        })\n\n        let filename = 'captured_image.jpg'\n        let fileSize = 0\n        let objectFormat = 0\n\n        if (infoResponse.data && infoResponse.data.length > 12) {\n            const view = new DataView(infoResponse.data.buffer, infoResponse.data.byteOffset + 12)\n            objectFormat = view.getUint16(4, true)\n            fileSize = view.getUint32(8, true)\n            console.log(`File size: ${fileSize} bytes`)\n\n            // Determine file extension based on object format\n            let extension = '.jpg'\n            if (objectFormat === 0xb101) {\n                extension = '.arw' // Sony RAW\n            } else if (objectFormat === 0x3802) {\n                extension = '.tiff'\n            }\n\n            // Generate filename with timestamp\n            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5)\n            filename = `IMG_${timestamp}${extension}`\n        }\n\n        // Get the actual image data\n        const response = await this.protocol.sendOperation({\n            code: PTPOperations.GET_OBJECT,\n            parameters: [SonyConstants.RECENT_IMAGE_HANDLE],\n            maxDataLength: fileSize > 0 ? fileSize + 1024 : 50 * 1024 * 1024, // Use file size or 50MB\n        })\n\n        if (response.code !== PTPResponses.OK || !response.data) {\n            throw new Error('Failed to download image')\n        }\n\n        // The data is already parsed without PTP container header\n        const imageBytes = response.data\n\n        return {\n            data: imageBytes,\n            format: objectFormat === 0xb101 ? ImageFormat.RAW : ImageFormat.JPEG,\n            width: 0, // TODO: Parse from EXIF\n            height: 0,\n            filename,\n        }\n    }\n\n    // Private helper methods\n\n    /**\n     * Set a Sony device property value\n     */\n    private async setPropertyValue(propCode: number, value: number | Uint8Array): Promise<void> {\n        // Convert number to Uint8Array if needed\n        let data: Uint8Array\n        if (typeof value === 'number') {\n            data = new Uint8Array(1)\n            data[0] = value\n        } else {\n            data = value\n        }\n\n        // Send SET_DEVICE_PROPERTY_VALUE command with data\n        await this.protocol.sendOperation({\n            code: SonyOperations.SET_DEVICE_PROPERTY_VALUE,\n            parameters: [propCode],\n            data: data,\n            hasDataPhase: true,\n        })\n    }\n\n    private async configureStillShooting(): Promise<void> {\n        // Set Dial Mode to Host Control\n        await this.setPropertyValue(SonyDeviceProperties.DIAL_MODE, new Uint8Array([SonyConstants.DIAL_MODE_HOST]))\n\n        // Set Operating Mode to Still Shooting\n        const stillModeData = new Uint8Array(4)\n        new DataView(stillModeData.buffer).setUint32(0, SonyConstants.STILL_CAPTURE_MODE, true)\n        await this.setPropertyValue(SonyDeviceProperties.STILL_CAPTURE_MODE, stillModeData)\n\n        // Set Save Media to Host Device\n        const saveMediaData = new Uint8Array(2)\n        new DataView(saveMediaData.buffer).setUint16(0, SonyConstants.SAVE_MEDIA_HOST, true)\n        await this.setPropertyValue(SonyDeviceProperties.SAVE_MEDIA, saveMediaData)\n    }\n\n    private async executeShootingSequence(): Promise<void> {\n        // Step 1: Half-press shutter button (initiate autofocus/metering)\n        await this.sendControlCommand(SonyDeviceProperties.SHUTTER_BUTTON_CONTROL, SonyConstants.SHUTTER_HALF_PRESS)\n        await this.sleep(500)\n\n        // Step 2: Half-press focus button (additional focus confirmation)\n        await this.sendControlCommand(SonyDeviceProperties.FOCUS_BUTTON_CONTROL, SonyConstants.FOCUS_HALF_PRESS)\n        await this.sleep(500)\n\n        // Step 3: Release focus button\n        await this.sendControlCommand(SonyDeviceProperties.FOCUS_BUTTON_CONTROL, SonyConstants.FOCUS_RELEASE)\n        await this.sleep(500)\n\n        // Step 4: Full-press shutter button (capture image)\n        await this.sendControlCommand(SonyDeviceProperties.SHUTTER_BUTTON_CONTROL, SonyConstants.SHUTTER_FULL_PRESS)\n        await this.sleep(500)\n    }\n\n    private async sendControlCommand(propCode: number, value: number): Promise<void> {\n        const data = new Uint8Array(2)\n        new DataView(data.buffer).setUint16(0, value, true)\n\n        await this.protocol.sendOperation({\n            code: SonyOperations.CONTROL_DEVICE_PROPERTY,\n            parameters: [propCode],\n            hasDataPhase: true,\n            data,\n        })\n    }\n\n    private parseLiveViewDataset(data: Uint8Array): {\n        jpeg: Uint8Array\n        width?: number\n        height?: number\n    } | null {\n        if (data.length < 16) {\n            return null\n        }\n\n        const view = new DataView(data.buffer, data.byteOffset)\n        const offsetToImage = view.getUint32(0, true)\n        const imageSize = view.getUint32(4, true)\n\n        console.log(`LiveView dataset: offset=${offsetToImage}, size=${imageSize}, dataLength=${data.length}`)\n\n        // Validate offsets and size\n        if (imageSize === 0) {\n            // No image data yet, return empty frame\n            return { jpeg: new Uint8Array(0) }\n        }\n\n        if (offsetToImage >= data.length || offsetToImage + imageSize > data.length) {\n            console.log(`Invalid offsets: offset=${offsetToImage}, size=${imageSize}, dataLength=${data.length}`)\n            return null\n        }\n\n        // Extract JPEG data\n        const jpeg = data.slice(offsetToImage, offsetToImage + imageSize)\n\n        // Verify it's a JPEG (starts with FFD8)\n        if (jpeg.length >= 2 && jpeg[0] === 0xff && jpeg[1] === 0xd8) {\n            console.log(`Valid JPEG found: ${jpeg.length} bytes`)\n        }\n\n        return { jpeg }\n    }\n\n    private parseOSDDataset(data: Uint8Array): Uint8Array | null {\n        if (data.length < 20) {\n            return null\n        }\n\n        const view = new DataView(data.buffer, data.byteOffset)\n        const offsetToImage = view.getUint32(0, true)\n        const imageSize = view.getUint32(4, true)\n\n        // Validate offsets\n        if (offsetToImage >= data.length || offsetToImage + imageSize > data.length) {\n            return null\n        }\n\n        // Extract PNG data\n        return data.slice(offsetToImage, offsetToImage + imageSize)\n    }\n\n    private sleep(ms: number): Promise<void> {\n        return new Promise(resolve => setTimeout(resolve, ms))\n    }\n\n    /**\n     * Refresh properties cache if needed\n     */\n    private async refreshPropertiesIfNeeded(): Promise<void> {\n        const now = Date.now()\n        if (!this.cachedProperties || now - this.propertiesLastFetched > this.PROPERTIES_CACHE_TTL) {\n            await this.getAllExtDevicePropInfo()\n            this.propertiesLastFetched = now\n        }\n    }\n\n    /**\n     * Get all extended device property info (Sony-specific)\n     */\n    private async getAllExtDevicePropInfo(): Promise<void> {\n        // Send GET_ALL_EXT_DEVICE_PROP_INFO command\n        const response = await this.protocol.sendOperation({\n            code: SonyOperations.GET_ALL_EXT_DEVICE_PROP_INFO,\n            parameters: [0, 1], // [Get all data, Enable extended info]\n            hasDataPhase: true,\n            maxDataLength: 10 * 1024 * 1024, // 10MB buffer for property data\n        })\n\n        if (response.code !== PTPResponses.OK) {\n            throw new Error(`Failed to get extended device properties: 0x${response.code.toString(16)}`)\n        }\n\n        if (!response.data || response.data.length < 12) {\n            throw new Error('No property data received')\n        }\n\n        console.log(`Received ${response.data.length} bytes for GET_ALL_EXT_DEVICE_PROP_INFO`)\n        console.log(\n            `First 20 bytes: ${Array.from(response.data.slice(0, 20))\n                .map(b => `0x${b.toString(16).padStart(2, '0')}`)\n                .join(' ')}`\n        )\n\n        // Parse the properties\n        this.cachedProperties = this.parseAllExtDevicePropInfo(response.data)\n\n        // Log what properties we found\n        console.log(`Parsed ${this.cachedProperties.size} properties out of ${370}`)\n        const importantProps = [0xd21e, 0xd20d, 0x5007] // ISO, Shutter, Aperture\n        for (const prop of importantProps) {\n            if (this.cachedProperties.has(prop)) {\n                console.log(`  Found property 0x${prop.toString(16)}: ${this.cachedProperties.get(prop).currentValue}`)\n            } else {\n                console.log(`  Missing property 0x${prop.toString(16)}`)\n            }\n        }\n\n        // Debug: Show all property codes we found\n        if (this.cachedProperties.size < 100) {\n            const allCodes = Array.from(this.cachedProperties.keys())\n                .map(c => `0x${c.toString(16)}`)\n                .join(', ')\n            console.log(`All property codes found: ${allCodes}`)\n        }\n    }\n\n    /**\n     * Parse the extended device property info response\n     */\n    private parseAllExtDevicePropInfo(data: Uint8Array): Map<number, any> {\n        const properties = new Map<number, any>()\n\n        // Skip PTP header (12 bytes)\n        const dataset = data.slice(12)\n        const view = new DataView(dataset.buffer, dataset.byteOffset)\n\n        // Skip number of elements (UINT64)\n        view.getBigUint64(0, true)\n\n        let offset = 8 // Start after numElements\n        let successCount = 0\n        let failCount = 0\n\n        // Parse properties until we run out of data\n        // Don't rely on numElements as the loop counter since parsing can fail\n        while (offset < dataset.length - 6 && successCount + failCount < 1000) {\n            try {\n                // Make sure we have at least minimum bytes for a property\n                if (offset + 8 > dataset.length) {\n                    break\n                }\n\n                const propInfo = this.parseSDIExtDevicePropInfo(dataset, offset)\n                if (propInfo) {\n                    properties.set(propInfo.propertyCode, propInfo)\n                    offset = propInfo.nextOffset\n                    successCount++\n\n                    // Verbose logging handled elsewhere if needed\n                } else {\n                    // Failed to parse, try small increment for recovery\n                    // Using 2-byte increment to find properties at odd offsets\n                    offset += 2\n                    failCount++\n                }\n            } catch (e: any) {\n                // Try simple recovery with 2-byte increment\n                offset += 2\n                failCount++\n            }\n        }\n\n        return properties\n    }\n\n    /**\n     * Parse Sony SDIO Extended Device Property Info dataset\n     * Handles the Sony-specific format with reserved bytes between header and values\n     */\n    parseSDIExtDevicePropInfo(data: Uint8Array, startOffset: number): SonyPropertyInfo | null {\n        try {\n            // Ensure we have enough data\n            if (startOffset + 8 > data.length) {\n                return null\n            }\n\n            const view = new DataView(data.buffer, data.byteOffset + startOffset)\n            let offset = 0\n\n            // Read header fields\n            const propertyCode = view.getUint16(offset, true)\n            offset += 2\n\n            // Validate property code - be strict about what's valid\n            // Valid ranges: standard PTP or vendor-specific\n            if (\n                !(\n                    (propertyCode >= SonyConstants.PTP_PROP_MIN && propertyCode <= SonyConstants.PTP_PROP_MAX) ||\n                    (propertyCode >= SonyConstants.VENDOR_PROP_MIN && propertyCode <= SonyConstants.VENDOR_PROP_MAX)\n                )\n            ) {\n                return null\n            }\n\n            const dataType = view.getUint16(offset, true)\n            offset += 2\n\n            // Validate data type - be strict\n            // Valid types: basic, array, or string\n            if (\n                !(\n                    (dataType >= SonyConstants.DATA_TYPE_MIN && dataType <= SonyConstants.DATA_TYPE_MAX) ||\n                    (dataType >= SonyConstants.DATA_TYPE_ARRAY_MIN && dataType <= SonyConstants.DATA_TYPE_ARRAY_MAX) ||\n                    dataType === SonyConstants.DATA_TYPE_STRING\n                )\n            ) {\n                return null\n            }\n\n            const getSet = view.getUint8(offset)\n            offset += 1\n\n            const isEnabled = view.getUint8(offset)\n            offset += 1\n\n            // CRITICAL: Skip reserved bytes based on data type\n            // Sony inserts reserved bytes between header fields and values\n            const reservedSize = this.getReservedSize(dataType)\n            offset += reservedSize\n\n            // Read current value\n            const { value: currentValue, size: currentSize } = this.readPropertyValue(view, offset, dataType)\n            offset += currentSize\n\n            // Read form flag\n            const formFlag = view.getUint8(offset)\n            offset += 1\n\n            const result: SonyPropertyInfo = {\n                propertyCode,\n                dataType,\n                getSet,\n                isEnabled,\n                currentValue,\n                formFlag,\n                nextOffset: startOffset + offset,\n            }\n\n            // Parse enumeration if present\n            if (formFlag === 0x02) {\n                // Read Set enumeration\n                const numEnumSet = view.getUint16(offset, true)\n                offset += 2\n\n                result.enumValuesSet = []\n                for (let i = 0; i < numEnumSet; i++) {\n                    const { value, size } = this.readPropertyValue(view, offset, dataType)\n                    result.enumValuesSet.push(value)\n                    offset += size\n                }\n\n                // Read GetSet enumeration\n                const numEnumGetSet = view.getUint16(offset, true)\n                offset += 2\n\n                result.enumValuesGetSet = []\n                for (let i = 0; i < numEnumGetSet; i++) {\n                    const { value, size } = this.readPropertyValue(view, offset, dataType)\n                    result.enumValuesGetSet.push(value)\n                    offset += size\n                }\n\n                result.nextOffset = startOffset + offset\n            }\n\n            return result\n        } catch (error) {\n            return null\n        }\n    }\n\n    /**\n     * Read a property value from a DataView based on PTP data type\n     * Wrapper around the shared readValue function\n     */\n    private readPropertyValue(view: DataView, offset: number, dataType: number): { value: any; size: number } {\n        return readValue(view, offset, dataType)\n    }\n\n    /**\n     * Get reserved bytes size for Sony SDIO properties based on data type\n     * Sony inserts reserved bytes between header fields and values\n     */\n    private getReservedSize(dataType: number): number {\n        const basicSize = this.getDataTypeSize(dataType)\n        // Sony uses the data type size as reserved bytes for alignment\n        return basicSize === 0 && (dataType & 0x4000) === 0x4000 ? 4 : basicSize\n    }\n\n    /**\n     * Get the size in bytes for a PTP data type\n     */\n    private getDataTypeSize(dataType: number): number {\n        switch (dataType) {\n            case PTPDataTypes.INT8:\n            case PTPDataTypes.UINT8:\n                return 1\n            case PTPDataTypes.INT16:\n            case PTPDataTypes.UINT16:\n                return 2\n            case PTPDataTypes.INT32:\n            case PTPDataTypes.UINT32:\n                return 4\n            case PTPDataTypes.INT64:\n            case PTPDataTypes.UINT64:\n                return 8\n            case PTPDataTypes.INT128:\n            case PTPDataTypes.UINT128:\n                return 16\n            case PTPDataTypes.STRING:\n                return 0 // Variable length\n            default:\n                if ((dataType & 0x4000) === 0x4000) {\n                    return 0 // Array - variable length\n                }\n                return 4\n        }\n    }\n\n    /**\n     * Extract a property value from the cached properties\n     */\n    private extractPropertyValue(propCode: number): any {\n        if (!this.cachedProperties) {\n            return undefined\n        }\n\n        const prop = this.cachedProperties.get(propCode)\n        return prop?.currentValue\n    }\n\n    /**\n     * Format aperture value for display\n     */\n    private formatAperture(value: number): string {\n        if (typeof value === 'number') {\n            // Sony stores aperture as value * 100\n            const fNumber = value / 100\n            return `f/${fNumber.toFixed(1)}`\n        }\n        return String(value)\n    }\n\n    /**\n     * Format shutter speed for display\n     */\n    private formatShutterSpeed(value: any): string {\n        if (typeof value === 'number') {\n            // Check for special values\n            if (value === 0x00000000) return 'BULB'\n            if (value === 0xffffffff) return 'N/A'\n\n            // Sony encodes shutter speed as 32-bit value:\n            // Upper 16 bits = numerator, Lower 16 bits = denominator\n            const numerator = (value >> 16) & 0xffff\n            const denominator = value & 0xffff\n\n            if (denominator === 0x000a) {\n                // Real number display (e.g., 1.5\")\n                return `${numerator / 10}\"`\n            } else if (numerator === 0x0001) {\n                // Fraction display (e.g., 1/1000)\n                return `1/${denominator}`\n            } else if (denominator !== 0) {\n                return `${numerator}/${denominator}`\n            }\n        }\n        return 'Unknown'\n    }\n\n    /**\n     * Format ISO value for display\n     */\n    private formatISO(value: number): string {\n        if (typeof value === 'number') {\n            // Special AUTO values\n            if (value === 0x00ffffff) return 'AUTO'\n            if (value === 0x01ffffff) return 'Multi Frame NR ISO AUTO'\n            if (value === 0x02ffffff) return 'Multi Frame NR High ISO AUTO'\n            if (value === 0xffffffff) return 'N/A'\n\n            // Check for Multi Frame NR modes (prefix byte)\n            const prefix = (value >> 24) & 0xff\n            let mode = ''\n            if (prefix === 0x01) {\n                mode = 'Multi Frame NR '\n            } else if (prefix === 0x02) {\n                mode = 'Multi Frame NR High '\n            }\n\n            // Extract the actual ISO value (lower 24 bits)\n            const isoValue = value & 0xffffff\n\n            // Sony uses direct decimal values for ISO\n            if (isoValue >= 10 && isoValue <= 1000000) {\n                return `${mode}ISO ${isoValue}`\n            }\n        }\n        return 'Unknown'\n    }\n}\n","import { TransportInterface } from '@transport/interfaces/transport.interface'\nimport { ProtocolInterface } from '@core/interfaces/protocol.interface'\nimport { MessageBuilderInterface } from '@core/interfaces/message-builder.interface'\nimport { PTPMessageBuilder } from '@core/ptp/ptp-message-builder'\nimport { PTPProtocol } from '@core/ptp/ptp-protocol'\nimport { CameraInterface } from './interfaces/camera.interface'\nimport { PropertyMapperInterface } from './interfaces/property-mapper.interface'\nimport { GenericPropertyMapper } from './generic/generic-property-mapper'\nimport { GenericPTPCamera } from './generic/generic-ptp-camera'\nimport { SonyCamera } from './vendors/sony/sony-camera'\nimport { SonyAuthenticator } from './vendors/sony/sony-authenticator'\n\n/**\n * Camera factory for creating camera implementations\n */\nexport class CameraFactory {\n    /**\n     * Create a Sony camera instance\n     * @param transport - Transport interface\n     */\n    createSonyCamera(transport: TransportInterface): CameraInterface {\n        const messageBuilder = this.createMessageBuilder()\n        const protocol = this.createProtocol(transport, messageBuilder)\n        const authenticator = new SonyAuthenticator()\n        return new SonyCamera(protocol, authenticator)\n    }\n\n    /**\n     * Create a Canon camera instance\n     * @param transport - Transport interface\n     */\n    createCanonCamera(transport: TransportInterface): CameraInterface {\n        this.createMessageBuilder()\n        this.createProtocol(transport, this.createMessageBuilder())\n        // TODO: Not implemented in old architecture\n        throw new Error('Canon camera not implemented in old architecture')\n    }\n\n    /**\n     * Create a Nikon camera instance\n     * @param transport - Transport interface\n     */\n    createNikonCamera(transport: TransportInterface): CameraInterface {\n        this.createMessageBuilder()\n        this.createProtocol(transport, this.createMessageBuilder())\n        // TODO: Not implemented in old architecture\n        throw new Error('Nikon camera not implemented in old architecture')\n    }\n\n    /**\n     * Create a generic PTP camera instance\n     * @param transport - Transport interface\n     */\n    createGenericCamera(transport: TransportInterface): CameraInterface {\n        const messageBuilder = this.createMessageBuilder()\n        const protocol = this.createProtocol(transport, messageBuilder)\n        const propertyMapper = this.createGenericPropertyMapper()\n        return new GenericPTPCamera(protocol, propertyMapper)\n    }\n\n    /**\n     * Create a camera instance by vendor\n     * @param vendor - Vendor name\n     * @param transport - Transport interface\n     */\n    create(vendor: string, transport: TransportInterface): CameraInterface {\n        const normalizedVendor = vendor.toLowerCase()\n\n        switch (normalizedVendor) {\n            case 'sony':\n                return this.createSonyCamera(transport)\n            case 'canon':\n                return this.createCanonCamera(transport)\n            case 'nikon':\n                return this.createNikonCamera(transport)\n            case 'fuji':\n            case 'fujifilm':\n                // TODO: Not implemented in old architecture\n                throw new Error('Fujifilm camera not implemented in old architecture')\n            case 'panasonic':\n                // TODO: Not implemented in old architecture\n                throw new Error('Panasonic camera not implemented in old architecture')\n            case 'olympus':\n                // TODO: Not implemented in old architecture\n                throw new Error('Olympus camera not implemented in old architecture')\n            default:\n                return this.createGenericCamera(transport)\n        }\n    }\n\n    /**\n     * Detect vendor from device info\n     * @param vendorId - USB vendor ID\n     * @param productId - USB product ID\n     */\n    detectVendor(vendorId: number, _productId?: number): string {\n        switch (vendorId) {\n            case 0x054c:\n                return 'sony'\n            case 0x04a9:\n                return 'canon'\n            case 0x04b0:\n                return 'nikon'\n            case 0x04cb:\n                return 'fujifilm'\n            case 0x2704:\n                return 'panasonic'\n            case 0x07b4:\n                return 'olympus'\n            default:\n                return 'generic'\n        }\n    }\n\n    /**\n     * Create a PTP message builder\n     */\n    private createMessageBuilder(): MessageBuilderInterface {\n        return new PTPMessageBuilder()\n    }\n\n    /**\n     * Create a PTP protocol instance\n     */\n    private createProtocol(transport: TransportInterface, messageBuilder: MessageBuilderInterface): ProtocolInterface {\n        return new PTPProtocol(transport, messageBuilder)\n    }\n\n    /**\n     * Create a generic property mapper\n     */\n    private createGenericPropertyMapper(): PropertyMapperInterface {\n        return new GenericPropertyMapper()\n    }\n}\n","import { DeviceFinderInterface, DeviceSearchCriteria, DeviceDescriptor } from '@transport/interfaces/endpoint.interface'\n\n/**\n * WebUSB device finder implementation\n */\nexport class WebUSBDeviceFinder implements DeviceFinderInterface {\n    /**\n     * Find USB devices matching criteria\n     */\n    async findDevices(criteria: DeviceSearchCriteria): Promise<DeviceDescriptor[]> {\n        const devices = await navigator.usb.getDevices()\n        console.log('[WebUSBDeviceFinder] Got devices from getDevices():', devices)\n        console.log('[WebUSBDeviceFinder] Search criteria:', criteria)\n\n        return devices\n            .filter(device => {\n                // Handle vendorId = 0 as \"any vendor\"\n                if (criteria.vendorId !== undefined && criteria.vendorId !== 0 && device.vendorId !== criteria.vendorId) {\n                    return false\n                }\n                // Handle productId = 0 as \"any product\"\n                if (criteria.productId !== undefined && criteria.productId !== 0 && device.productId !== criteria.productId) {\n                    return false\n                }\n                // WebUSB doesn't easily expose interface class info without opening device\n                return true\n            })\n            .map(device => ({\n                device,\n                vendorId: device.vendorId,\n                productId: device.productId,\n                manufacturer: device.manufacturerName || undefined,\n                product: device.productName || undefined,\n                serialNumber: device.serialNumber || undefined,\n            }))\n    }\n\n    /**\n     * Request device access (WebUSB only)\n     */\n    async requestDevice(criteria: DeviceSearchCriteria): Promise<DeviceDescriptor> {\n        const filters: USBDeviceFilter[] = []\n        \n        // If looking for PTP devices (cameras)\n        if (criteria.class === 6) {\n            // Request any device with PTP class\n            filters.push({ classCode: 6 })\n        } else if (criteria.vendorId !== undefined && criteria.vendorId !== 0) {\n            filters.push({ vendorId: criteria.vendorId })\n            if (criteria.productId !== undefined && criteria.productId !== 0) {\n                filters[0] = { ...filters[0], productId: criteria.productId }\n            }\n        } else {\n            // If no specific criteria, request PTP devices by default\n            filters.push({ classCode: 6 })\n        }\n\n        console.log('[WebUSBDeviceFinder] Requesting device with filters:', filters)\n        const device = await navigator.usb.requestDevice({ filters })\n\n        return {\n            device,\n            vendorId: device.vendorId,\n            productId: device.productId,\n            manufacturer: device.manufacturerName || undefined,\n            product: device.productName || undefined,\n            serialNumber: device.serialNumber || undefined,\n        }\n    }\n\n    /**\n     * Get all available USB devices\n     */\n    async getAllDevices(): Promise<DeviceDescriptor[]> {\n        const devices = await navigator.usb.getDevices()\n        return devices.map(device => ({\n            device,\n            vendorId: device.vendorId,\n            productId: device.productId,\n            manufacturer: device.manufacturerName || undefined,\n            product: device.productName || undefined,\n            serialNumber: device.serialNumber || undefined,\n        }))\n    }\n}","import { CameraFactory } from '@camera/camera-factory'\nimport { CameraOptions, CameraDescriptor } from './types'\n\nimport { WebUSBDeviceFinder as USBDeviceFinder } from '@transport/usb/usb-device-finder.browser'\n\n/**\n * Request camera access from the user (WebUSB only)\n * Must be called from a user interaction (button click, etc.)\n */\nexport async function requestCameraAccess(): Promise<CameraDescriptor | null> {\n    const deviceFinder = new USBDeviceFinder()\n    const cameraFactory = new CameraFactory()\n    \n    try {\n        // Request device with PTP interface class\n        const device = await deviceFinder.requestDevice({ class: 6 })\n        \n        const vendor = cameraFactory.detectVendor(device.vendorId)\n        return {\n            vendor: vendor.charAt(0).toUpperCase() + vendor.slice(1),\n            model: device.product || 'Camera',\n            serialNumber: device.serialNumber,\n            usb: {\n                vendorId: device.vendorId,\n                productId: device.productId,\n            },\n        }\n    } catch (error) {\n        console.error('Failed to request camera access:', error)\n        return null\n    }\n}\n\nexport async function listCameras(options?: CameraOptions): Promise<CameraDescriptor[]> {\n    const deviceFinder = new USBDeviceFinder()\n    const cameraFactory = new CameraFactory()\n\n    const searchCriteria = {\n        vendorId: options?.usb?.vendorId || 0,\n        productId: options?.usb?.productId || 0,\n    }\n\n    const devices = await deviceFinder.findDevices(searchCriteria)\n\n    let cameras: CameraDescriptor[] = devices.map(device => {\n        const vendor = cameraFactory.detectVendor(device.vendorId)\n        return {\n            vendor: vendor.charAt(0).toUpperCase() + vendor.slice(1),\n            model: 'Camera',\n            serialNumber: device.serialNumber,\n            usb: {\n                vendorId: device.vendorId,\n                productId: device.productId,\n            },\n        }\n    })\n\n    if (options?.vendor) {\n        cameras = cameras.filter(camera => camera.vendor.toLowerCase() === options.vendor!.toLowerCase())\n    }\n\n    if (options?.model) {\n        cameras = cameras.filter(camera => camera.model.toLowerCase().includes(options.model!.toLowerCase()))\n    }\n\n    if (options?.serialNumber) {\n        cameras = cameras.filter(camera => camera.serialNumber === options.serialNumber)\n    }\n\n    if (options?.ip) {\n        // Future: IP camera discovery will be added here\n        // For now, we can manually add IP cameras if specified\n        if (options.ip.host) {\n            const ipCamera: CameraDescriptor = {\n                vendor: options.vendor || 'Unknown',\n                model: options.model || 'IP Camera',\n                serialNumber: options.serialNumber,\n                ip: {\n                    host: options.ip.host,\n                    port: options.ip.port || 15740,\n                },\n            }\n            cameras.push(ipCamera)\n        }\n    }\n\n    return cameras\n}\n\nexport function watchCameras(callback: (cameras: CameraDescriptor[]) => void, options?: CameraOptions): () => void {\n    const intervalMilliseconds = 1000\n    let lastCameraCount = -1\n\n    const checkCameras = async () => {\n        try {\n            const cameras = await listCameras(options)\n            if (cameras.length !== lastCameraCount) {\n                lastCameraCount = cameras.length\n                callback(cameras)\n            }\n        } catch (error) {\n            console.error('Error watching cameras:', error)\n        }\n    }\n\n    // Initial check\n    checkCameras()\n\n    const interval = setInterval(checkCameras, intervalMilliseconds)\n\n    return () => clearInterval(interval)\n}\n","/**\n * Minimal EventEmitter implementation for browser environments\n */\nexport class EventEmitter {\n    private events: Map<string | symbol, Function[]> = new Map()\n\n    on(event: string | symbol, listener: Function): this {\n        if (!this.events.has(event)) {\n            this.events.set(event, [])\n        }\n        this.events.get(event)!.push(listener)\n        return this\n    }\n\n    once(event: string | symbol, listener: Function): this {\n        const onceWrapper = (...args: any[]) => {\n            this.off(event, onceWrapper)\n            listener.apply(this, args)\n        }\n        return this.on(event, onceWrapper)\n    }\n\n    off(event: string | symbol, listener: Function): this {\n        const listeners = this.events.get(event)\n        if (listeners) {\n            const index = listeners.indexOf(listener)\n            if (index !== -1) {\n                listeners.splice(index, 1)\n            }\n        }\n        return this\n    }\n\n    removeListener(event: string | symbol, listener: Function): this {\n        return this.off(event, listener)\n    }\n\n    emit(event: string | symbol, ...args: any[]): boolean {\n        const listeners = this.events.get(event)\n        if (listeners && listeners.length > 0) {\n            listeners.forEach(listener => {\n                listener.apply(this, args)\n            })\n            return true\n        }\n        return false\n    }\n\n    removeAllListeners(event?: string | symbol): this {\n        if (event) {\n            this.events.delete(event)\n        } else {\n            this.events.clear()\n        }\n        return this\n    }\n\n    listenerCount(event: string | symbol): number {\n        const listeners = this.events.get(event)\n        return listeners ? listeners.length : 0\n    }\n\n    listeners(event: string | symbol): Function[] {\n        return this.events.get(event) || []\n    }\n\n    setMaxListeners(_n: number): this {\n        // No-op for compatibility\n        return this\n    }\n\n    getMaxListeners(): number {\n        return Number.POSITIVE_INFINITY\n    }\n}","/**\n * Endpoint management interface for transport implementations\n */\nexport interface EndpointManagerInterface {\n    /**\n     * Configure endpoints for a device\n     * @param device - Device to configure endpoints for\n     */\n    configureEndpoints(device: unknown): Promise<EndpointConfiguration>\n\n    /**\n     * Release endpoints\n     */\n    releaseEndpoints(): Promise<void>\n\n    /**\n     * Get current endpoint configuration\n     */\n    getConfiguration(): EndpointConfiguration | null\n\n    /**\n     * Clear endpoint halt condition\n     * @param endpoint - Endpoint to clear\n     */\n    clearHalt(endpoint: EndpointType): Promise<void>\n}\n\n/**\n * Endpoint configuration\n */\nexport interface EndpointConfiguration {\n    bulkIn: unknown\n    bulkOut: unknown\n    interrupt?: unknown\n}\n\n/**\n * Endpoint types\n */\nexport enum EndpointType {\n    BULK_IN = 'bulk_in',\n    BULK_OUT = 'bulk_out',\n    INTERRUPT = 'interrupt',\n}\n\n/**\n * Device finder interface for locating devices\n */\nexport interface DeviceFinderInterface {\n    /**\n     * Find devices matching criteria\n     * @param criteria - Search criteria\n     */\n    findDevices(criteria: DeviceSearchCriteria): Promise<DeviceDescriptor[]>\n\n    /**\n     * Request device access (for web environments)\n     * @param criteria - Device selection criteria\n     */\n    requestDevice(criteria: DeviceSearchCriteria): Promise<DeviceDescriptor>\n\n    /**\n     * Get list of all available devices\n     */\n    getAllDevices(): Promise<DeviceDescriptor[]>\n}\n\n/**\n * Device search criteria\n */\nexport interface DeviceSearchCriteria {\n    vendorId?: number\n    productId?: number\n    class?: number\n    subclass?: number\n    protocol?: number\n}\n\n/**\n * Device descriptor\n */\nexport interface DeviceDescriptor {\n    device: unknown\n    vendorId: number\n    productId: number\n    manufacturer?: string\n    product?: string\n    serialNumber?: string\n}\n","import { TransportInterface, TransportType, DeviceIdentifier } from '@transport/interfaces/transport.interface'\nimport { EndpointManagerInterface, EndpointType, DeviceFinderInterface } from '@transport/interfaces/endpoint.interface'\n\n/**\n * USB transport implementation for PTP communication\n */\nexport class USBTransport implements TransportInterface {\n    private device: any = null\n    private interface: any = null\n    private endpoints: any = null\n    private connected = false\n    private readonly isWebEnvironment = typeof navigator !== 'undefined' && 'usb' in navigator\n    private deviceInfo: { vendorId: number; productId: number } | null = null\n\n    constructor(\n        private readonly deviceFinder: DeviceFinderInterface,\n        private readonly endpointManager: EndpointManagerInterface\n    ) {}\n\n    /**\n     * Connect to a USB device\n     */\n    async connect(deviceIdentifier: DeviceIdentifier): Promise<void> {\n        if (this.connected) {\n            throw new Error('Already connected')\n        }\n\n        // Find device - include PTP class filter to ensure we find PTP devices\n        const devices = await this.deviceFinder.findDevices({\n            vendorId: deviceIdentifier.vendorId,\n            productId: deviceIdentifier.productId,\n            class: 6, // PTP/Still Image class\n        })\n\n        let device = devices.find(d => {\n            if (deviceIdentifier.serialNumber) {\n                return d.serialNumber === deviceIdentifier.serialNumber\n            }\n            return true\n        })\n\n        if (!device && this.isWebEnvironment) {\n            // Request device access in web environment\n            device = await this.deviceFinder.requestDevice({\n                vendorId: deviceIdentifier.vendorId,\n                productId: deviceIdentifier.productId,\n            })\n        }\n\n        if (!device) {\n            throw new Error(`Device not found: ${deviceIdentifier.vendorId}:${deviceIdentifier.productId}`)\n        }\n\n        this.device = device.device\n        this.deviceInfo = { vendorId: device.vendorId, productId: device.productId }\n\n        if (this.isWebEnvironment) {\n            await this.connectWebUSB()\n        } else {\n            await this.connectNodeUSB()\n        }\n\n        this.connected = true\n    }\n\n    /**\n     * Disconnect from the current device\n     */\n    async disconnect(): Promise<void> {\n        if (!this.connected) {\n            return\n        }\n\n        if (this.isWebEnvironment) {\n            if (this.interface) {\n                await this.device.releaseInterface(this.interface.interfaceNumber)\n            }\n            await this.device.close()\n        } else {\n            await this.endpointManager.releaseEndpoints()\n            try {\n                this.device.close()\n            } catch {\n                // Ignore errors during close\n            }\n        }\n\n        this.device = null\n        this.interface = null\n        this.endpoints = null\n        this.connected = false\n    }\n\n    /**\n     * Send data to the device\n     */\n    async send(data: Uint8Array): Promise<void> {\n        if (!this.connected || !this.endpoints) {\n            throw new Error('Not connected')\n        }\n\n        const buffer = Buffer.from(data)\n        const endpointAddress = this.isWebEnvironment\n            ? this.endpoints.bulkOut.endpointNumber\n            : this.endpoints.bulkOut.descriptor.bEndpointAddress\n        console.log(`USB Transport: Sending ${buffer.length} bytes to endpoint 0x${endpointAddress.toString(16)}`)\n\n        if (this.isWebEnvironment) {\n            const result = await this.device.transferOut(this.endpoints.bulkOut.endpointNumber, buffer)\n            if (result.status !== 'ok') {\n                throw new Error(`Transfer failed: ${result.status}`)\n            }\n        } else {\n            return new Promise((resolve, reject) => {\n                const handleTransfer = (error: any) => {\n                    console.log(`USB Transport: Transfer callback, error: ${error}`)\n                    if (error) {\n                        this.handleNodeUSBError(error, buffer, resolve, reject)\n                    } else {\n                        resolve()\n                    }\n                }\n\n                console.log(`USB Transport: Calling transfer with ${buffer.length} bytes`)\n                this.endpoints.bulkOut.transfer(buffer, handleTransfer)\n            })\n        }\n    }\n\n    /**\n     * Receive data from the device\n     */\n    async receive(maxLength: number = 8192): Promise<Uint8Array> {\n        if (!this.connected || !this.endpoints) {\n            throw new Error('Not connected')\n        }\n\n        if (this.isWebEnvironment) {\n            const result = await this.device.transferIn(this.endpoints.bulkIn.endpointNumber, maxLength)\n            if (result.status !== 'ok') {\n                throw new Error(`Transfer failed: ${result.status}`)\n            }\n            return new Uint8Array(result.data.buffer)\n        } else {\n            return new Promise((resolve, reject) => {\n                const handleReceive = (error: any, data: Buffer) => {\n                    if (error) {\n                        // Handle stall on receive\n                        if (error.errno === 4 || error.errno === -9 || error.message?.includes('STALL')) {\n                            console.log('USB receive stall detected, clearing halt...')\n                            this.endpointManager\n                                .clearHalt(EndpointType.BULK_IN)\n                                .then(() => {\n                                    console.log('USB receive halt cleared, retrying...')\n                                    this.endpoints.bulkIn.transfer(maxLength, (retryError: any, retryData: Buffer) => {\n                                        if (retryError) {\n                                            reject(retryError)\n                                        } else {\n                                            resolve(new Uint8Array(retryData))\n                                        }\n                                    })\n                                })\n                                .catch(() => {\n                                    reject(error)\n                                })\n                        } else {\n                            reject(error)\n                        }\n                    } else {\n                        resolve(new Uint8Array(data))\n                    }\n                }\n                this.endpoints.bulkIn.transfer(maxLength, handleReceive)\n            })\n        }\n    }\n\n    /**\n     * Check if connected\n     */\n    isConnected(): boolean {\n        return this.connected\n    }\n\n    /**\n     * Reset the USB device\n     */\n    async reset(): Promise<void> {\n        if (!this.connected || !this.device) {\n            throw new Error('Not connected')\n        }\n\n        if (!this.isWebEnvironment) {\n            // Node USB reset\n            try {\n                this.device.reset()\n            } catch {\n                // Ignore reset errors\n            }\n        }\n        // WebUSB doesn't have a reset method\n    }\n\n    /**\n     * Get transport type\n     */\n    getType(): TransportType {\n        return TransportType.USB\n    }\n\n    /**\n     * Get device info (vendor ID and product ID)\n     */\n    getDeviceInfo(): { vendorId: number; productId: number } | null {\n        return this.deviceInfo\n    }\n\n    private async connectWebUSB(): Promise<void> {\n        await this.device.open()\n\n        // Configure endpoints\n        const config = await this.endpointManager.configureEndpoints(this.device)\n        this.endpoints = config\n\n        // Find the interface number from the endpoint configuration\n        const configuration = this.device.configuration || this.device.configurations[0]\n        for (const intf of configuration.interfaces) {\n            const alt = intf.alternates[0]\n            if (alt.interfaceClass === 6 && alt.interfaceSubclass === 1) {\n                this.interface = intf\n                await this.device.claimInterface(intf.interfaceNumber)\n                break\n            }\n        }\n\n        if (!this.interface) {\n            throw new Error('Failed to claim PTP interface')\n        }\n    }\n\n    private async connectNodeUSB(): Promise<void> {\n        this.device.open()\n\n        // Configure endpoints (this also claims the interface)\n        const config = await this.endpointManager.configureEndpoints(this.device)\n        this.endpoints = config\n    }\n\n    private handleNodeUSBError(\n        error: any,\n        buffer: Buffer,\n        resolve: (value: void | PromiseLike<void>) => void,\n        reject: (reason?: any) => void\n    ): void {\n        // Handle stall/pipe errors with retry\n        console.log(`USB Transport: Handling error - errno: ${error.errno}, message: ${error.message}`)\n        if (\n            error.errno === -9 ||\n            error.errno === 4 ||\n            error.message?.includes('PIPE') ||\n            error.message?.includes('STALL')\n        ) {\n            console.log('USB Transport: Clearing halt and retrying...')\n            // Clear halt and retry\n            this.endpointManager\n                .clearHalt(EndpointType.BULK_OUT)\n                .then(() => {\n                    console.log('USB Transport: Halt cleared, retrying transfer...')\n                    // Retry once after clearing\n                    this.endpoints.bulkOut.transfer(buffer, (retryError: any) => {\n                        if (retryError) {\n                            console.log(`USB Transport: Retry failed: ${retryError}`)\n                            reject(retryError)\n                        } else {\n                            console.log('USB Transport: Retry successful!')\n                            resolve()\n                        }\n                    })\n                })\n                .catch(clearError => {\n                    console.log(`USB Transport: Failed to clear halt: ${clearError}`)\n                    reject(error)\n                })\n        } else {\n            reject(error)\n        }\n    }\n}\n","import { EndpointManagerInterface, EndpointConfiguration, EndpointType } from '@transport/interfaces/endpoint.interface'\n\n/**\n * WebUSB endpoint manager implementation\n */\nexport class WebUSBEndpointManager implements EndpointManagerInterface {\n    private configuration: EndpointConfiguration | null = null\n\n    /**\n     * Configure endpoints for a USB device\n     */\n    async configureEndpoints(device: any): Promise<EndpointConfiguration> {\n        // Find PTP interface (class 6, subclass 1, protocol 1)\n        const config = device.configuration || device.configurations[0]\n        let ptpInterface: any = null\n\n        for (const intf of config.interfaces) {\n            const alt = intf.alternates[0]\n            if (alt.interfaceClass === 6 && alt.interfaceSubclass === 1) {\n                ptpInterface = intf\n                break\n            }\n        }\n\n        if (!ptpInterface) {\n            throw new Error('PTP interface not found')\n        }\n\n        // Find endpoints\n        const endpoints: EndpointConfiguration = {\n            bulkIn: null,\n            bulkOut: null,\n            interrupt: undefined,\n        }\n\n        const alt = ptpInterface.alternates[0]\n        for (const ep of alt.endpoints) {\n            if (ep.direction === 'in' && ep.type === 'bulk') {\n                endpoints.bulkIn = ep\n            } else if (ep.direction === 'out' && ep.type === 'bulk') {\n                endpoints.bulkOut = ep\n            } else if (ep.direction === 'in' && ep.type === 'interrupt') {\n                endpoints.interrupt = ep\n            }\n        }\n\n        if (!endpoints.bulkIn || !endpoints.bulkOut) {\n            throw new Error('Required bulk endpoints not found')\n        }\n\n        this.configuration = endpoints\n\n        return endpoints\n    }\n\n    /**\n     * Release endpoints\n     */\n    async releaseEndpoints(): Promise<void> {\n        // WebUSB handles this during device.releaseInterface\n        this.configuration = null\n    }\n\n    /**\n     * Get current endpoint configuration\n     */\n    getConfiguration(): EndpointConfiguration | null {\n        return this.configuration\n    }\n\n    /**\n     * Clear endpoint halt condition\n     */\n    async clearHalt(_endpoint: EndpointType): Promise<void> {\n        // WebUSB handles this automatically\n        return\n    }\n}","import { TransportInterface, TransportType, TransportOptions } from './interfaces/transport.interface'\nimport { DeviceFinderInterface, EndpointManagerInterface } from './interfaces/endpoint.interface'\nimport { USBTransport } from './usb/usb-transport'\nimport { WebUSBDeviceFinder } from './usb/usb-device-finder.browser'\nimport { WebUSBEndpointManager } from './usb/usb-endpoint-manager.browser'\n\n/**\n * Web transport factory for creating transport implementations\n */\nexport class TransportFactory {\n    /**\n     * Create a USB transport instance\n     * @param options - USB transport options\n     */\n    createUSBTransport(_options?: USBTransportOptions): TransportInterface {\n        const deviceFinder = this.createUSBDeviceFinder()\n        const endpointManager = this.createUSBEndpointManager()\n        return new USBTransport(deviceFinder, endpointManager)\n    }\n\n    /**\n     * Create an IP transport instance\n     * @param options - IP transport options\n     */\n    createIPTransport(_options: IPTransportOptions): TransportInterface {\n        // TODO: Not implemented in old architecture\n        throw new Error('IP transport not implemented in old architecture')\n    }\n\n    /**\n     * Create a transport instance by type\n     * @param type - Transport type\n     * @param options - Transport options\n     */\n    create(type: TransportType, options?: unknown): TransportInterface {\n        switch (type) {\n            case TransportType.USB:\n                return this.createUSBTransport(options as USBTransportOptions)\n            case TransportType.IP:\n                return this.createIPTransport(options as IPTransportOptions)\n            case TransportType.BLUETOOTH:\n                // TODO: Not implemented in old architecture\n                throw new Error('Bluetooth transport not implemented in old architecture')\n            default:\n                throw new Error(`Unknown transport type: ${type as string}`)\n        }\n    }\n\n    /**\n     * Create a device finder for USB devices\n     */\n    createUSBDeviceFinder(): DeviceFinderInterface {\n        return new WebUSBDeviceFinder()\n    }\n\n    /**\n     * Create an endpoint manager for USB devices\n     */\n    createUSBEndpointManager(): EndpointManagerInterface {\n        return new WebUSBEndpointManager()\n    }\n}\n\n/**\n * USB transport options\n */\nexport interface USBTransportOptions extends TransportOptions {\n    interfaceNumber?: number\n    alternateInterface?: number\n    claimInterface?: boolean\n}\n\n/**\n * IP transport options\n */\nexport interface IPTransportOptions extends TransportOptions {\n    address: string\n    port: number\n    protocol?: 'tcp' | 'udp'\n    keepAlive?: boolean\n    keepAliveInterval?: number\n}","import { Photo as PhotoType } from './types'\n\nexport class Photo implements PhotoType {\n    public data: ArrayBuffer | Uint8Array | Buffer\n    public filename: string\n    public size: number\n    public capturedAt: Date\n\n    constructor(data: ArrayBuffer | Uint8Array | Buffer, filename: string, capturedAt?: Date) {\n        this.data = data\n        this.filename = filename\n        this.size = data instanceof ArrayBuffer ? data.byteLength : data.length\n        this.capturedAt = capturedAt || new Date()\n    }\n\n    async save(filename?: string): Promise<void> {\n        const blob = this.toBlob()\n        const url = URL.createObjectURL(blob)\n        const a = document.createElement('a')\n        a.href = url\n        a.download = filename || this.filename\n        a.click()\n        URL.revokeObjectURL(url)\n    }\n\n    toBlob(): Blob {\n        // Ensure data is in the correct format for Blob constructor\n        let blobData: ArrayBuffer\n        if (this.data instanceof ArrayBuffer) {\n            blobData = this.data\n        } else {\n            // Convert typed array to ArrayBuffer\n            blobData = this.data.buffer.slice(\n                this.data.byteOffset, \n                this.data.byteOffset + this.data.byteLength\n            ) as ArrayBuffer\n        }\n        return new Blob([blobData], { type: 'image/jpeg' })\n    }\n\n    async toFile(): Promise<File> {\n        // Ensure data is in the correct format for File constructor\n        let fileData: ArrayBuffer\n        if (this.data instanceof ArrayBuffer) {\n            fileData = this.data\n        } else {\n            // Convert typed array to ArrayBuffer\n            fileData = this.data.buffer.slice(\n                this.data.byteOffset,\n                this.data.byteOffset + this.data.byteLength\n            ) as ArrayBuffer\n        }\n        return new File([fileData], this.filename, { \n            type: 'image/jpeg',\n            lastModified: this.capturedAt.getTime()\n        })\n    }\n\n    toJSON() {\n        return {\n            filename: this.filename,\n            size: this.size,\n            capturedAt: this.capturedAt,\n            dataSize: this.size,\n        }\n    }\n}","import { CameraFactory } from '@camera/camera-factory'\nimport { CameraInterface } from '@camera/interfaces/camera.interface'\nimport { TransportType } from '@transport/interfaces/transport.interface'\nimport { DeviceProperty } from '@camera/properties/device-properties'\nimport { listCameras } from './discovery.browser'\nimport { CameraOptions, CameraDescriptor, Photo as PhotoType, Frame, ExposureMode } from './types'\nimport { EventEmitter } from '../utils/event-emitter.browser'\nimport { TransportFactory } from '@transport/transport-factory.browser'\nimport { Photo } from './photo.browser'\n\nexport class Camera extends EventEmitter {\n    private options: CameraOptions\n    private cameraImplementation?: CameraInterface\n    private transportFactory: TransportFactory\n    private cameraFactory: CameraFactory\n    private _vendor?: string\n    private _model?: string\n    private _serialNumber?: string\n\n    constructor(options?: CameraOptions | CameraDescriptor) {\n        super()\n        this.options = options || {}\n        this.transportFactory = new TransportFactory()\n        this.cameraFactory = new CameraFactory()\n    }\n\n    async connect(): Promise<void> {\n        if (!this.options.usb?.productId && !this.options.ip?.host) {\n            const cameras = await listCameras(this.options)\n\n            if (cameras.length === 0) {\n                const filters = []\n                if (this.options.vendor) filters.push(`vendor: ${this.options.vendor}`)\n                if (this.options.model) filters.push(`model: ${this.options.model}`)\n                if (this.options.usb?.vendorId) filters.push(`USB vendor: 0x${this.options.usb.vendorId.toString(16)}`)\n\n                const filterMsg = filters.length > 0 ? ` matching filters: ${filters.join(', ')}` : ''\n                throw new Error(`No cameras found${filterMsg}. Please connect a camera via USB.`)\n            }\n\n            const firstCamera = cameras[0]\n            if (firstCamera) {\n                this.options = { ...this.options, ...firstCamera }\n                this._vendor = firstCamera.vendor\n                this._model = firstCamera.model\n                this._serialNumber = firstCamera.serialNumber\n            }\n        }\n\n        await this.establishConnection()\n    }\n\n    private async establishConnection(): Promise<void> {\n        if (this.options.ip) {\n            throw new Error('IP connections not yet implemented')\n        }\n\n        const transport = this.transportFactory.create(TransportType.USB, {\n            timeout: this.options.timeout,\n        })\n\n        await transport.connect({\n            vendorId: this.options.usb?.vendorId || 0,\n            productId: this.options.usb?.productId || 0,\n            serialNumber: this.options.serialNumber,\n        })\n\n        const detectedVendor =\n            this.options.vendor ||\n            this.cameraFactory.detectVendor(this.options.usb?.vendorId || 0, this.options.usb?.productId || 0)\n\n        this.cameraImplementation = this.cameraFactory.create(detectedVendor, transport)\n        await this.cameraImplementation.connect()\n\n        // Set vendor/model/serial from options if not already set\n        if (!this._vendor) this._vendor = this.options.vendor || detectedVendor\n        if (!this._model) this._model = this.options.model || 'Unknown'\n        if (!this._serialNumber) this._serialNumber = this.options.serialNumber || 'Unknown'\n    }\n\n    async disconnect(): Promise<void> {\n        if (this.cameraImplementation) {\n            await this.cameraImplementation.disconnect()\n            this.cameraImplementation = undefined\n        }\n        this.emit('disconnect')\n    }\n\n    isConnected(): boolean {\n        return this.cameraImplementation?.isConnected() || false\n    }\n\n    get vendor(): string {\n        if (!this._vendor) throw new Error('Camera not connected')\n        return this._vendor\n    }\n\n    get model(): string {\n        if (!this._model) throw new Error('Camera not connected')\n        return this._model\n    }\n\n    get serialNumber(): string {\n        if (!this._serialNumber) throw new Error('Camera not connected')\n        return this._serialNumber\n    }\n\n    async takePhoto(): Promise<PhotoType> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        try {\n            await this.cameraImplementation.captureImage()\n            const images = await this.cameraImplementation.listImages()\n            if (images.length === 0) {\n                throw new Error('No images found after capture')\n            }\n            const latestImage = images[images.length - 1]\n            if (!latestImage) {\n                throw new Error('No image found after capture')\n            }\n            const imageData = await this.cameraImplementation.downloadImage(latestImage.handle)\n            const buffer = imageData instanceof Buffer ? imageData : Buffer.from(imageData as any)\n            const photo = new Photo(buffer, latestImage.filename || 'unknown')\n            this.emit('photo', photo)\n            return photo\n        } catch (error) {\n            this.emit('error', error)\n            throw error\n        }\n    }\n\n    async getISO(): Promise<number> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const value = await this.cameraImplementation.getDeviceProperty(DeviceProperty.ISO)\n        return value as number\n    }\n\n    async setISO(value: number): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        await this.cameraImplementation.setDeviceProperty(DeviceProperty.ISO, value)\n    }\n\n    async getShutterSpeed(): Promise<string> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const value = await this.cameraImplementation.getDeviceProperty(DeviceProperty.SHUTTER_SPEED)\n        return this.formatShutterSpeed(value)\n    }\n\n    async setShutterSpeed(value: string): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const numericValue = this.parseShutterSpeed(value)\n        await this.cameraImplementation.setDeviceProperty(DeviceProperty.SHUTTER_SPEED, numericValue)\n    }\n\n    async getAperture(): Promise<string> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const value = await this.cameraImplementation.getDeviceProperty(DeviceProperty.APERTURE)\n        return this.formatAperture(value)\n    }\n\n    async setAperture(value: string): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const numericValue = this.parseAperture(value)\n        await this.cameraImplementation.setDeviceProperty(DeviceProperty.APERTURE, numericValue)\n    }\n\n    async getExposureMode(): Promise<ExposureMode> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const value = await this.cameraImplementation.getDeviceProperty(DeviceProperty.EXPOSURE_MODE)\n        return this.mapExposureMode(value)\n    }\n\n    async setExposureMode(value: ExposureMode): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const numericValue = this.mapExposureModeToNumeric(value)\n        await this.cameraImplementation.setDeviceProperty(DeviceProperty.EXPOSURE_MODE, numericValue)\n    }\n\n    async getProperty(property: DeviceProperty): Promise<any> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        return this.cameraImplementation.getDeviceProperty(property)\n    }\n\n    async setProperty(property: DeviceProperty, value: any): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        await this.cameraImplementation.setDeviceProperty(property, value)\n    }\n\n    async getProperties(): Promise<Map<DeviceProperty, any>> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const properties = new Map<DeviceProperty, any>()\n        const commonProperties = [\n            DeviceProperty.ISO,\n            DeviceProperty.SHUTTER_SPEED,\n            DeviceProperty.APERTURE,\n            DeviceProperty.EXPOSURE_MODE,\n            DeviceProperty.WHITE_BALANCE,\n            DeviceProperty.FOCUS_MODE,\n        ]\n\n        for (const prop of commonProperties) {\n            try {\n                const value = await this.cameraImplementation.getDeviceProperty(prop)\n                properties.set(prop, value)\n            } catch {\n                // Property not supported by this camera\n            }\n        }\n\n        return properties\n    }\n\n    async startLiveView(callback: (frame: Frame) => void): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        // Live view implementation would go here\n        // For now, this is a placeholder\n        callback // Reference to avoid unused parameter error\n        throw new Error('Live view not yet implemented')\n    }\n\n    async stopLiveView(): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        // Live view stop implementation would go here\n    }\n\n    async listPhotos(): Promise<PhotoType[]> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const images = await this.cameraImplementation.listImages()\n        return images.map(img => new Photo(Buffer.alloc(0), img.filename || 'unknown'))\n    }\n\n    async downloadPhoto(photo: PhotoType): Promise<Buffer> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const images = await this.cameraImplementation.listImages()\n        const image = images.find(img => img.filename === photo.filename)\n        if (!image) throw new Error('Photo not found on camera')\n        const data = await this.cameraImplementation.downloadImage(image.handle)\n        return data instanceof Buffer ? data : Buffer.from(data as any)\n    }\n\n    async deletePhoto(photo: PhotoType): Promise<void> {\n        if (!this.cameraImplementation) throw new Error('Camera not connected')\n        const filename = photo.filename || ''\n        const images = await this.cameraImplementation.listImages()\n        const image = images.find(img => (img.filename || '') === filename)\n        if (!image) throw new Error('Photo not found on camera')\n        await this.cameraImplementation.deleteImage(image.handle)\n    }\n\n    private formatShutterSpeed(value: any): string {\n        if (typeof value === 'string') return value\n        if (typeof value === 'number') {\n            if (value >= 1) return `${value}`\n            return `1/${Math.round(1 / value)}`\n        }\n        return String(value)\n    }\n\n    private parseShutterSpeed(value: string): number {\n        if (value.includes('/')) {\n            const parts = value.split('/')\n            const numerator = parts[0] || '1'\n            const denominator = parts[1] || '1'\n            return parseFloat(numerator) / parseFloat(denominator)\n        }\n        return parseFloat(value)\n    }\n\n    private formatAperture(value: any): string {\n        if (typeof value === 'string') return value\n        if (typeof value === 'number') return `f/${value}`\n        return String(value)\n    }\n\n    private parseAperture(value: string): number {\n        if (value.startsWith('f/')) {\n            return parseFloat(value.substring(2))\n        }\n        return parseFloat(value)\n    }\n\n    private mapExposureMode(value: any): ExposureMode {\n        if (typeof value === 'string') return value as ExposureMode\n        // Map numeric values to exposure modes (camera-specific)\n        const modeMap: { [key: number]: ExposureMode } = {\n            0: 'auto',\n            1: 'manual',\n            2: 'aperture',\n            3: 'shutter',\n        }\n        return modeMap[value as number] || 'auto'\n    }\n\n    private mapExposureModeToNumeric(mode: ExposureMode): number {\n        const modeMap: { [key in ExposureMode]: number } = {\n            auto: 0,\n            manual: 1,\n            aperture: 2,\n            shutter: 3,\n        }\n        return modeMap[mode]\n    }\n}\n","import { Frame as FrameType } from './types'\n\nexport class Frame implements FrameType {\n    public data: Buffer\n    public width: number\n    public height: number\n    public timestamp: number\n\n    constructor(data: Buffer, width: number, height: number, timestamp?: number) {\n        this.data = data\n        this.width = width\n        this.height = height\n        this.timestamp = timestamp || Date.now()\n    }\n\n    get aspectRatio(): number {\n        return this.width / this.height\n    }\n\n    get size(): number {\n        return this.data.length\n    }\n\n    toJSON() {\n        return {\n            width: this.width,\n            height: this.height,\n            timestamp: this.timestamp,\n            dataSize: this.data.length,\n            aspectRatio: this.aspectRatio,\n        }\n    }\n}\n","/**\n * Common property value constants\n */\n\n/**\n * Exposure modes\n */\nexport enum ExposureMode {\n    AUTO = 'auto',\n    PROGRAM = 'program',\n    APERTURE_PRIORITY = 'aperturePriority',\n    SHUTTER_PRIORITY = 'shutterPriority',\n    MANUAL = 'manual',\n    BULB = 'bulb',\n    SCENE = 'scene',\n}\n\n/**\n * Focus modes\n */\nexport enum FocusMode {\n    MANUAL = 'manual',\n    AUTO_SINGLE = 'autoSingle',\n    AUTO_CONTINUOUS = 'autoContinuous',\n    AUTO_AUTOMATIC = 'autoAutomatic',\n    DMF = 'dmf',\n    POWER_FOCUS = 'powerFocus',\n}\n\n/**\n * White balance modes\n */\nexport enum WhiteBalanceMode {\n    AUTO = 'auto',\n    DAYLIGHT = 'daylight',\n    CLOUDY = 'cloudy',\n    SHADE = 'shade',\n    TUNGSTEN = 'tungsten',\n    FLUORESCENT = 'fluorescent',\n    FLASH = 'flash',\n    CUSTOM = 'custom',\n    KELVIN = 'kelvin',\n}\n\n/**\n * Drive modes\n */\nexport enum DriveMode {\n    SINGLE = 'single',\n    CONTINUOUS_LOW = 'continuousLow',\n    CONTINUOUS_HIGH = 'continuousHigh',\n    SELF_TIMER_2 = 'selfTimer2',\n    SELF_TIMER_10 = 'selfTimer10',\n    BRACKETING = 'bracketing',\n}\n\n/**\n * Image quality modes\n */\nexport enum ImageQuality {\n    RAW = 'raw',\n    FINE = 'fine',\n    NORMAL = 'normal',\n    BASIC = 'basic',\n    RAW_JPEG_FINE = 'rawJpegFine',\n    RAW_JPEG_NORMAL = 'rawJpegNormal',\n    RAW_JPEG_BASIC = 'rawJpegBasic',\n}\n\n/**\n * Flash modes\n */\nexport enum FlashMode {\n    OFF = 'off',\n    AUTO = 'auto',\n    FILL = 'fill',\n    RED_EYE = 'redEye',\n    SLOW_SYNC = 'slowSync',\n    REAR_SYNC = 'rearSync',\n    WIRELESS = 'wireless',\n}\n\n/**\n * Metering modes\n */\nexport enum MeteringMode {\n    MULTI = 'multi',\n    CENTER_WEIGHTED = 'centerWeighted',\n    SPOT = 'spot',\n    ENTIRE_SCREEN_AVG = 'entireScreenAvg',\n    HIGHLIGHT = 'highlight',\n}\n\n/**\n * AF area modes\n */\nexport enum AFAreaMode {\n    WIDE = 'wide',\n    ZONE = 'zone',\n    CENTER = 'center',\n    FLEXIBLE_SPOT = 'flexibleSpot',\n    EXPANDED_FLEXIBLE_SPOT = 'expandedFlexibleSpot',\n    TRACKING = 'tracking',\n}\n\n/**\n * Color space modes\n */\nexport enum ColorSpace {\n    SRGB = 'sRGB',\n    ADOBE_RGB = 'adobeRGB',\n    PRO_PHOTO = 'proPhoto',\n}\n"],"names":["MessageType","PTPDataType","ContainerTypes","PTPOperations","PTPResponses","PTPEvents","PTPDeviceProperties","PTPOperationNames","acc","name","code","PTPResponseNames","PTPEventNames","PTPDevicePropertyNames","PTPError","code","message","operation","PTPMessageBuilder","operation","parameters","paramCount","length","buffer","view","ContainerTypes","index","param","data","uint8View","type","code","transactionId","paramBytes","payload","containerType","SonyOperations","PTPOperations","SonyDeviceProperties","PTPDeviceProperties","SDIOPhases","SonyConstants","formatFNumber","value","formatShutterSpeed","numerator","denominator","formatISO","prefix","mode","isoValue","PTPProtocol","_PTPProtocol","transport","messageBuilder","sessionId","command","PTPOperations","responseData","response","PTPResponses","PTPError","operation","transactionId","hasDataPhase","receivedData","dataMessage","maxLength","dataResponse","parsedResponse","eventData","parsedEvent","code","parameters","data","operationCode","SonyOperations","DeviceProperty","DataType","PropertyUnit","GenericPropertyMapper","PTPDeviceProperties","vendorCode","genericProp","property","value","numValue","rawValue","decoder","ImageFormat","GenericPTPCamera","protocol","propertyMapper","response","PTPOperations","PTPResponses","property","vendorCode","value","vendorValue","data","handles","images","handle","info","storageIds","storageInfos","id","view","offset","dataType","getSet","count","i","storageId","objectFormat","compressedSize","_data","ids","storageType","filesystemType","accessCapability","maxCapacity","freeSpaceInBytes","freeSpaceInImages","SonyPropertyMapper","SonyDeviceProperties","property","vendorCode","value","rawValue","formatShutterSpeed","formatFNumber","formatISO","data","view","denominator","seconds","fNumber","lowerValue","match","numerator","SonyAuthenticator","protocol","SDIOPhases","phase","response","SonyOperations","PTPResponses","SonyConstants","version","FrameFormat","FocusStatus","PTPDataTypes","readValue","view","offset","dataType","numChars","str","i","char","count","baseType","values","totalSize","result","SonyCamera","GenericPTPCamera","protocol","sonyAuthenticator","SonyPropertyMapper","SonyAuthenticator","controlData","SonyConstants","SonyOperations","SonyDeviceProperties","timeSinceLastRequest","waitTime","infoResponse","PTPOperations","width","height","imageSize","imageData","retryCount","maxRetries","response","PTPResponses","liveViewDataset","b","parsed","enabled","osdValue","osdData","error","pngData","aperture","shutterSpeed","iso","property","vendorCode","rawValue","filename","fileSize","objectFormat","extension","propCode","value","data","stillModeData","saveMediaData","offsetToImage","jpeg","ms","resolve","now","importantProps","prop","allCodes","c","properties","dataset","successCount","failCount","propInfo","startOffset","propertyCode","getSet","isEnabled","reservedSize","currentValue","currentSize","formFlag","numEnumSet","size","numEnumGetSet","basicSize","numerator","denominator","prefix","mode","isoValue","CameraFactory","transport","messageBuilder","protocol","authenticator","SonyAuthenticator","SonyCamera","propertyMapper","GenericPTPCamera","vendor","vendorId","_productId","PTPMessageBuilder","PTPProtocol","GenericPropertyMapper","WebUSBDeviceFinder","criteria","devices","device","filters","requestCameraAccess","deviceFinder","WebUSBDeviceFinder","cameraFactory","CameraFactory","device","vendor","error","listCameras","options","searchCriteria","cameras","camera","ipCamera","watchCameras","callback","lastCameraCount","checkCameras","interval","EventEmitter","event","listener","onceWrapper","args","listeners","index","_n","EndpointType","USBTransport","deviceFinder","endpointManager","deviceIdentifier","device","d","data","buffer","endpointAddress","result","resolve","reject","handleTransfer","error","maxLength","handleReceive","retryError","retryData","config","configuration","intf","alt","clearError","WebUSBEndpointManager","device","config","ptpInterface","intf","alt","endpoints","ep","_endpoint","TransportFactory","_options","deviceFinder","endpointManager","USBTransport","type","options","WebUSBDeviceFinder","WebUSBEndpointManager","Photo","data","filename","capturedAt","blob","url","a","blobData","fileData","Camera","EventEmitter","options","TransportFactory","CameraFactory","cameras","listCameras","filters","filterMsg","firstCamera","transport","detectedVendor","images","latestImage","imageData","buffer","photo","Photo","error","value","numericValue","property","properties","commonProperties","prop","callback","img","image","data","filename","parts","numerator","denominator","mode","Frame","data","width","height","timestamp","ExposureMode","FocusMode","WhiteBalanceMode","DriveMode","ImageQuality","FlashMode","MeteringMode","AFAreaMode","ColorSpace"],"mappings":"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","debugId":null}},
    {"offset": {"line": 2190, "column": 0}, "map": {"version":3,"sources":["file:///Users/kevinschaich/repositories/jpglab/fuse/examples/web/app/page.tsx"],"sourcesContent":["'use client'\n\nimport { Camera, listCameras, requestCameraAccess, CameraDescriptor } from '../../../dist/web'\nimport { useEffect, useState } from \"react\";\n\nexport default function Home() {\n  const [cameras, setCameras] = useState<CameraDescriptor[]>([])\n  const [error, setError] = useState<string>('')\n  const [connected, setConnected] = useState(false)\n  const [hasWebUSB, setHasWebUSB] = useState(false)\n\n  // Check WebUSB support after mounting (to avoid hydration issues)\n  useEffect(() => {\n    setHasWebUSB(!!navigator.usb)\n  }, [])\n\n  // Check for already paired devices\n  const checkCameras = async () => {\n    try {\n      // First check what WebUSB sees directly\n      if (navigator.usb) {\n        const usbDevices = await navigator.usb.getDevices()\n        console.log('Raw USB devices from navigator.usb.getDevices():', usbDevices)\n      }\n      \n      const cams = await listCameras()\n      console.log('Found cameras from listCameras():', cams)\n      setCameras(cams)\n    } catch (err) {\n      console.error('Error listing cameras:', err)\n      setError(err?.toString() || 'Failed to list cameras')\n    }\n  }\n\n  useEffect(() => {\n    checkCameras()\n  }, [])\n\n  // Request permission for a new USB device\n  const requestCameraPermission = async () => {\n    try {\n      // Use the library's requestCameraAccess function\n      const camera = await requestCameraAccess()\n      \n      if (camera) {\n        console.log('Camera access granted:', camera)\n        // Add the newly granted camera to the list immediately\n        setCameras(prev => [...prev, camera])\n        // Also refresh the full list\n        setTimeout(checkCameras, 100)\n      } else {\n        setError('No camera selected')\n      }\n    } catch (err: any) {\n      console.error('Error requesting device:', err)\n      setError(err?.toString() || 'Failed to request device')\n    }\n  }\n\n  // Connect to a camera\n  const connectCamera = async () => {\n    try {\n      const camera = new Camera()\n      await camera.connect()\n      setConnected(true)\n      console.log('Connected to camera!')\n    } catch (err) {\n      console.error('Error connecting:', err)\n      setError(err?.toString() || 'Failed to connect')\n    }\n  }\n\n  return (\n    <div className=\"font-sans grid grid-rows-[auto_1fr_auto] items-center justify-items-center min-h-screen p-8 gap-8\">\n      <div className=\"text-center\">\n        <h1 className=\"text-2xl font-bold mb-4\">WebUSB Camera Control</h1>\n        \n        {/* Show WebUSB support status */}\n        <div className=\"mb-4\">\n          WebUSB Support: {hasWebUSB ? ' Available' : ' Not Available'}\n        </div>\n\n        {/* Permission request button */}\n        <button \n          onClick={requestCameraPermission}\n          className=\"bg-blue-500 text-white px-4 py-2 rounded mr-2 hover:bg-blue-600\"\n        >\n          Request Camera Access\n        </button>\n\n        {/* Refresh button */}\n        <button \n          onClick={checkCameras}\n          className=\"bg-gray-500 text-white px-4 py-2 rounded mr-2 hover:bg-gray-600\"\n        >\n          Refresh Camera List\n        </button>\n\n        {/* Connect button */}\n        {cameras.length > 0 && !connected && (\n          <button \n            onClick={connectCamera}\n            className=\"bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600\"\n          >\n            Connect to First Camera\n          </button>\n        )}\n      </div>\n\n      {/* Camera list */}\n      <div className=\"text-center\">\n        <h2 className=\"text-xl mb-2\">Available Cameras: {cameras.length}</h2>\n        {cameras.length === 0 ? (\n          <p className=\"text-gray-500\">\n            No cameras found. Click \"Request Camera Access\" to grant permission.\n          </p>\n        ) : (\n          <div className=\"space-y-2\">\n            {cameras.map((camera, idx) => (\n              <div key={camera.serialNumber || idx} className=\"border p-2 rounded\">\n                <div>Vendor: {camera.vendor}</div>\n                <div>Model: {camera.model}</div>\n                <div>Serial: {camera.serialNumber || 'N/A'}</div>\n                {camera.usb && (\n                  <div className=\"text-sm text-gray-600\">\n                    USB: {camera.usb.vendorId.toString(16)}:{camera.usb.productId.toString(16)}\n                  </div>\n                )}\n              </div>\n            ))}\n          </div>\n        )}\n\n        {connected && (\n          <div className=\"mt-4 text-green-600 font-bold\">\n             Camera Connected!\n          </div>\n        )}\n      </div>\n\n      {/* Error display */}\n      {error && (\n        <div className=\"text-red-500 text-center\">\n          Error: {error}\n        </div>\n      )}\n    </div>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2437, "column": 0}, "map": {"version":3,"sources":["file:///Users/kevinschaich/repositories/jpglab/fuse/examples/web/node_modules/next/src/server/route-modules/app-page/module.compiled.js"],"sourcesContent":["if (process.env.NEXT_RUNTIME === 'edge') {\n  module.exports = require('next/dist/server/route-modules/app-page/module.js')\n} else {\n  if (process.env.__NEXT_EXPERIMENTAL_REACT) {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo-experimental.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page-experimental.runtime.prod.js')\n      }\n    }\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.dev.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.dev.js')\n      }\n    } else {\n      if (process.env.TURBOPACK) {\n        module.exports = require('next/dist/compiled/next-server/app-page-turbo.runtime.prod.js')\n      } else {\n        module.exports = require('next/dist/compiled/next-server/app-page.runtime.prod.js')\n      }\n    }\n  }\n}\n"],"names":["process","env","NEXT_RUNTIME","module","exports","require","__NEXT_EXPERIMENTAL_REACT","NODE_ENV","TURBOPACK"],"mappings":"AAAA,IAAIA,QAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;;KAElC;IACL,IAAIF,QAAQC,GAAG,CAACK,yBAAyB,EAAE;;SAcpC;QACL,IAAIN,QAAQC,GAAG,CAACM,QAAQ,KAAK,WAAe;YAC1C,IAAIP,QAAQC,GAAG,CAACO,SAAS,eAAE;gBACzBL,OAAOC,OAAO,GAAGC,QAAQ;YAC3B,OAAO;;QAGT,OAAO;;IAOT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2456, "column": 0}, "map": {"version":3,"sources":["file:///Users/kevinschaich/repositories/jpglab/fuse/examples/web/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react-jsx-dev-runtime.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.ReactJsxDevRuntime\n"],"names":["module","exports","require","vendored","ReactJsxDevRuntime"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,yIACRC,QAAQ,CAAC,YAAY,CAAEC,kBAAkB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2461, "column": 0}, "map": {"version":3,"sources":["file:///Users/kevinschaich/repositories/jpglab/fuse/examples/web/node_modules/next/src/server/route-modules/app-page/vendored/ssr/react.ts"],"sourcesContent":["module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-ssr']!.React\n"],"names":["module","exports","require","vendored","React"],"mappings":"AAAAA,OAAOC,OAAO,GACZC,QAAQ,yIACRC,QAAQ,CAAC,YAAY,CAAEC,KAAK","ignoreList":[0],"debugId":null}}]
}